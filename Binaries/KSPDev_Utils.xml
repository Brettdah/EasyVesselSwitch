<?xml version="1.0"?>
<doc>
    <assembly>
        <name>KSPDev_Utils</name>
    </assembly>
    <members>
        <member name="T:KSPDev.ConfigUtils.AbstractCollectionTypeProto">
             <summary>A base class for a proto of a collection of values.</summary>
             <remarks>Collection of collections is not supported. Though, descendands may use own
             (de)serialization approach to handle nested collections.
             <para>All descendants of this class must implement a constructor which accepts a single
             argument: the type of the collection. Constructor can throw <see cref="T:System.ArgumentException"/>
             if passed type is unacceptable.</para>
             </remarks>
             <example>As a good example of overriding of this class see
             <see cref="T:KSPDev.ConfigUtils.GenericCollectionTypeProto"/>. Though, it tries to be universal and, hence, works
             via reflection. You don't need to deal with reflections as long as your custom proto used for
             the fields of known types only.
             <code>
             class MyBooleanCollection {
               public void AddItem(bool itemValue) {
                 // ...some custom code...
               }
               public IEnumerable GetMyVeryCustomIterator() {
                 // ...some custom code...
                 return res;
               }
             }
            
             class MyBooleanCollectionProto : AbstractCollectionTypeProto {
               public MyBooleanCollectionProto() : base(typeof(bool)) {}
            
               public override Type GetItemType() {
                 return typeof(bool);
               }
               public override IEnumerable GetEnumerator(object instance) {
                 return (instance as MyBooleanCollection).GetMyVeryCustomIterator(); 
               }
               public override void AddItem(object instance, object item) {
                 (instance as MyBooleanCollection).AddItem((bool) item);
               }
             }
             </code>
             </example>
             <seealso cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
             <seealso cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractCollectionTypeProto.#ctor(System.Type)">
            <param name="containerType">A type of the collection (i.e. an immediate field's type).</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractCollectionTypeProto.GetItemType">
            <summary>Returns type of items in the collection.</summary>
            <returns>An item type.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractCollectionTypeProto.GetEnumerator(System.Object)">
            <summary>Returns enumerable object for the collection.</summary>
            <param name="instance">An instance to get the enumerable for.</param>
            <returns>An enumerable of objects. Type of the items is determined by the relevant
            <see cref="T:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractCollectionTypeProto.AddItem(System.Object,System.Object)">
            <summary>Adds an item into the collection.</summary>
            <param name="instance">A collection instance to add item into.</param>
            <param name="item">An item to add. The item must be of the same type as
            <see cref="M:KSPDev.ConfigUtils.AbstractCollectionTypeProto.GetItemType"/> specifies.</param>
        </member>
        <member name="T:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto">
            <summary>A base class for a proto of a single value.</summary>
            <remarks>All descendands of this class must implement a default constructor.</remarks>
            <example>See real overrides in <see cref="T:KSPDev.ConfigUtils.PrimitiveTypesProto"/> and
            <see cref="T:KSPDev.ConfigUtils.KspTypesProto"/>.
            <para>Here is how you could implement your own proto to persist string array as a string.</para>
            <code>
            class StringArrayProto : AbstractOrdinaryValueTypeProto {
              public override bool CanHandle(Type type) {
                return typeof(string[]) == type;
              }
              public override string SerializeToString(object value) {
                return string.Join(",", (value as string[]));
              }
              public override object ParseFromString(string value, Type type) {
                // Due to check in CanHandle we know the type is string[].
                return value.Split(',');
              }
            }
            </code>
            </example>
            <seealso cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
            <seealso cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto.#ctor">
            <summary>Default constructor must be the only constructor of the proto.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto.CanHandle(System.Type)">
            <summary>Tells if proto can handle the specified type.</summary>
            <param name="type">A type in question.</param>
            <returns><c>true</c> if proto can (de)serialize values of the type.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto.SerializeToString(System.Object)">
            <summary>Serializes value into a string.</summary>
            <remarks>In general avoid using <c>ToString()</c> methods to produce the serialized value.
            Such methods are not designed to be unambiguous.</remarks>
            <param name="value">A value to serialize.</param>
            <returns>A string representation of the value. It doesn't need to be human readable.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto.ParseFromString(System.String,System.Type)">
            <summary>Makes a value from the string representation.</summary>
            <param name="value">A string produced by <see cref="M:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto.SerializeToString(System.Object)"/>.</param>
            <param name="type">A type to convert the value into.</param>
            <returns>A new and initialized instance of the requested type.</returns>
            <exception cref="T:System.ArgumentException">If value cannot be parsed.</exception>
        </member>
        <member name="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute">
             <summary>A base for any persitent field annotation.</summary>
             <remarks>Descendands must initialize at least <see cref="F:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute._ordinaryTypeProto"/> field. If
             <see cref="F:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute._collectionTypeProto"/> is set then the field is considered a persistent
             collection of values.
             <para>See more examples in <see cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>.</para>
             </remarks>
             <example>A "shortcut" attributes could be declared like this: 
             <code>
             class MyTypeAttribute : AbstractPersistentFieldAttribute {
               public MyTypeAttribute(string cfgPath) : base(cfgPath) {
                 _ordinaryTypeProto = typeof(PrimitiveTypesProto);
               }
             }
            
             class MyTypesCollectionAttribute : AbstractPersistentFieldAttribute {
               public MyTypesCollectionAttribute(string cfgPath) : base(cfgPath) {
                 _ordinaryTypeProto = typeof(PrimitiveTypesProto);
                 _collectionTypeProto = typeof(GenericCollectionTypeProto);
               }
             }
             </code>
             </example>
             <seealso cref="T:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto"/>
             <seealso cref="T:KSPDev.ConfigUtils.AbstractCollectionTypeProto"/>
             <seealso cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute.path">
            <summary>Relative path to the value or node. Case-insensitive.</summary>
            <remarks>Absolute path depends on the context.</remarks>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute.group">
            <summary>A tag for a group of fields.</summary>
            <remarks>Group can be used when reading/writing values via <see cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
            to process only a subset of the persistent fields of the class. It's case-insensitive.
            </remarks>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute._ordinaryTypeProto">
            <summary>A proto that (de)serializes field's value as a simple string.</summary>
            <remarks>This type must be a descendant of <see cref="T:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto"/>.
            </remarks>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute._collectionTypeProto">
            <summary>A proto that handles field's value as a collection of persistent values.</summary>
            <remarks>If it's <c>null</c> then field is assumed to be not a collection.</remarks>
            <para>This type must be a descendant of <see cref="T:KSPDev.ConfigUtils.AbstractCollectionTypeProto"/>.
            </para>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute.#ctor(System.String)">
            <param name="cfgPath">A path to the fields's value in the config. Components must be separated
            by symbol '/'. The path is relative, the absolute path is determined when doing actual
            (de)serialization. The path is case-insensitive.</param>
        </member>
        <member name="T:KSPDev.ConfigUtils.AbstractPersistentFieldsFileAttribute">
            <summary>A base for any persistent fields file annotation.</summary>
            <remarks>This attribute doesn't assume much logic so, you basically override it only to create
            "shortcuts".</remarks>
            <seealso cref="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsInType(System.Type,System.Object,System.String)"/>
            <seealso cref="M:KSPDev.ConfigUtils.ConfigAccessor.WriteFieldsFromType(System.Type,System.Object,System.String)"/>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldsFileAttribute.group">
            <summary>A group tag which is handled by this annotation.</summary>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldsFileAttribute.nodePath">
            <summary>A path to the node which will be the root for the fields in the group.</summary>
            <remarks>By setting different root for every group and/or type you may combine multiple
            settings in the same config file. When <see cref="F:KSPDev.ConfigUtils.AbstractPersistentFieldsFileAttribute.configFilePath"/> is empty this value is an
            absolute path on the game's database.</remarks>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldsFileAttribute.configFilePath">
            <summary>An optional relative path to the config file.</summary>
            <remarks>Absolute name is resolved via <see cref="M:KSPDev.FSUtils.KspPaths.makePluginPath(System.String)"/>. If left
            empty then data is read from the game's database. Note, that database access is read-only.  
            </remarks>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractPersistentFieldsFileAttribute.#ctor(System.String,System.String,System.String)">
            <param name="configFilePath">A relative or an absolute path to the file. It's resolved via
            <see cref="M:KSPDev.FSUtils.KspPaths.makePluginPath(System.String)"/>. If empty then data is read from database.
            </param>
            <param name="nodePath">A root for the persistent fields when saving or loading via this
            annotation. If empty then root node of the file is used. Cannot be <c>null</c></param>
            <param name="group">A group of the annotation. When saving or loading persistent fields only
            the fields of this group will be considered. Must not be <c>null</c>.</param>
        </member>
        <member name="T:KSPDev.ConfigUtils.PersistentFieldsDatabaseAttribute">
            <summary>
            A simple annotation to associate a persistent group with a game's database key.
            </summary>
            <remarks>
            <para>This annotation is basically a shortcut to <see cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>.
            You may use the latter with an empty config file path if you find it more convinient.</para>
            <para>Each <c>.cfg</c> file in the mod's folders is scanned and indexed by the game on start. The
            data is stored in the database where it can be accessed from the game. The access is read-only,
            any changes to the node returned from the database won't affect the database state.</para>
            <para>Config file in the database is indentified by a key which is made of three major parts:
            <list type="">
            <item>A file path relative to <c>GameData</c>.</item>
            <item>The config filename without extension.</item>
            <item>Node path inside the file starting from the root. I.e. the root node should have name as
            well.</item>
            </list>
            </para>
            <para>E.g. key <c>KIS/settings/KISConfig/Global</c> addresses a node <c>KISConfig/Global</c> in file
            stored at <c>GameData/KIS/settings.cfg</c>.
            </para>
            <para>Special case is subfolders <c>PluginData</c>, they are ignored during database scan. Put
            there configs that can change during the gameplay. Remember, that even a tiny change in the
            config will trigger database re-compilation on the next start which may significantly impact
            game loading time.</para>
            <para>Database is actively used by
            <see href="https://github.com/sarbian/ModuleManager">ModuleManager</see> (a.k.a. MM). Be wise
            when choosing if fields should be read from a file or from the database. Module manager
            patches are only applied on the database, they don't affect the config files. E.g. part configs
            are frequently updated by the patches but never updated from the gameplay so, reading them via
            database is the best choice. Various mod's settings, on the other hand, can change during the
            game but will unlikely be a target for a MM patch, put them into <c>PluginData</c> folder and
            read/write via file methods.</para>
            </remarks>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>
            <seealso cref="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsInType(System.Type,System.Object,System.String)"/>
            <seealso cref="M:KSPDev.ConfigUtils.ConfigAccessor.WriteFieldsFromType(System.Type,System.Object,System.String)"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentFieldsDatabaseAttribute.#ctor(System.String,System.String)">
            <param name="nodePath">An absolute path to the node in the game's database.</param>
            <param name="group">A group of the annotation. When saving or loading persistent fields only
            the fields of this group will be considered. Must not be <c>null</c>.</param>
        </member>
        <member name="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute">
             <summary>
             A simple annotation to associate a persistent group with a configuration file.
             </summary>
             <remarks>Multiple annotations are allowed on the class. It's not required to have unique
             filename/nodePath/group set in every annontation but it's highly recommended.  
             <para>This assignment is ignored in the nested classes. Though, when using nested class as an
             immediate target of the call the annotation will be handled just fine.</para>
             </remarks>
             <example>
             <code>
             [PersistentFieldsFile("settings.cfg", "Root/Default")]
             [PersistentFieldsFile("settings-other.cfg", "", "abc")]
             [PersistentFieldsFile("settings-nested-bad.cfg", "", "nevermind")]
             class ClassWithPersistentFields {
               [PersistentField("field1")]
               private int intField = 0;
             
               [PersistentFieldsFile("settings-nested-good.cfg", "Root/Nested", "nevermind")]
               internal struct ComplexType {
                 [PersistentField("val1", group = "nevermind")]
                 public bool boolVal;
                 [PersistentField("val2", group = "nevermind")]
                 public Color colorVal;
               }
             
               [PersistentField("complexField1", group = "abc")]
               private ComplexType complexField;
             
               void SaveFields() {
                 // Save a default group of fields. 
                 ConfigAccessor.WriteFieldsFromType(instance: this);
                 /* File will be created at "GameData/settings.cfg":
                  * Root
                  * {
                  *   Default
                  *   {
                  *     field1: 0
                  *   }
                  * }
                  */
             
                 // Save group "abc". Note that the complex type only defines fields for group "nevermind"
                 // but it's ignored. The group is only honored on the immediate type, i.e.
                 // ClassWithPersistentFields in this case. 
                 ConfigAccessor.WriteFieldsFromType(instance: this, group: "abc");
                 /* File will be created at "GameData/settings-other.cfg".
                  * {
                  *   complexField1
                  *   {
                  *     val1: False
                  *     val2: 0,0,0,1
                  *   }
                  * }
                  */
             
                 // Try to use incorrect setup and save group "nevermind" for "this". 
                 // File will be created at "GameData/settings-nested-bad.cfg". And it will be empty since
                 // no fields for this group is defined in class ClassWithPersistentFields.
                 ConfigAccessor.WriteFieldsFromType(instance: this, group: "nevermind");
             
                 // Proper use of the nested complex type would be like this.
                 var test = new ComplexType() {
                     boolVal = true,
                     colorVal = Color.white
                 };
                 ConfigAccessor.WriteFieldsFromType(instance: test, group: "nevermind");
                 /* File will be created at "GameData/settings-nested-good.cfg".
                  * Root
                  * {
                  *   Nested
                  *   {
                  *     complexField1
                  *     {
                  *       val1: True
                  *       val2: 1,1,1,1
                  *     }
                  *   }
                  * }
                  */
            
                 // The following call makes the similar output but with different values.    
                 ConfigAccessor.WriteFieldsFromType(instance: complexField, group: "nevermind");
               }
             }
             </code>
             Note that this annotation only adds or re-creates the node specified by <c>nodePath</c>. If
             target file had other nodes they will not be overwritten. Though, you may expect the file
             structure to be re-ordered and comments (if any) lost. The file is actualy changed, it's read,
             updated, and saved.
             </example>
             <seealso cref="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsInType(System.Type,System.Object,System.String)"/>
             <seealso cref="M:KSPDev.ConfigUtils.ConfigAccessor.WriteFieldsFromType(System.Type,System.Object,System.String)"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentFieldsFileAttribute.#ctor(System.String,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:KSPDev.ConfigUtils.GenericCollectionTypeProto">
            <summary>A proto handler for a simple generic collection.</summary>
            <remarks>Generic must have exactly one arguent, implement method <c>Add</c> for adding new
            items, and implement <see cref="T:System.Collections.IEnumerable"/>.</remarks>
        </member>
        <member name="M:KSPDev.ConfigUtils.GenericCollectionTypeProto.#ctor(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.GenericCollectionTypeProto.GetItemType">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.GenericCollectionTypeProto.GetEnumerator(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.GenericCollectionTypeProto.AddItem(System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:KSPDev.ConfigUtils.OrdinaryFieldHandler">
            <summary>
            A handler that manages ordinary fields. All type specific handling is done via a proto.
            </summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.OrdinaryFieldHandler.#ctor(KSPDev.ConfigUtils.PersistentField,System.Type,System.Type)">
            <param name="persistentField">A persitent field descriptor.</param>
            <param name="valueType">A type to handle. If field is a collection then this type is a type of
            the collection's item.</param>
            <param name="simpleTypeProtoType">A proto that handles (de)serializing (in)to a simple string.
            if this proto cannot handle <paramref name="valueType"/> then the type will be attempted to be
            handled as a complex type.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.OrdinaryFieldHandler.SerializeValue(System.Object)">
            <summary>Converts field value into a form suitable for storing into config file.</summary>
            <remarks>Values that can be handled by the proto are transformed into simple strings, and
            saved as string values into the config. Structs and classes are considred "compound types"
            (see <see cref="M:KSPDev.ConfigUtils.OrdinaryFieldHandler.IsCompound"/>), i.e. types that have nested fields in them. Such types are
            converted into a config node.</remarks>
            <param name="value">A field's value to convert.</param>
            <returns>String or <see cref="T:ConfigNode"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.OrdinaryFieldHandler.DeserializeValue(System.Object)">
            <summary>Converts a value from config into an actual fiel's value.</summary>
            <param name="cfgValue">A string if value can be handled by the proto or
            <see cref="T:ConfigNode"/> if type is compound.</param>
            <returns>Field's value.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.OrdinaryFieldHandler.IsCompound">
            <summary>Determines if the field is complex type consiting of more fields.</summary>
            <returns><c>true</c> if type can have nested persitent fields.</returns>
        </member>
        <member name="T:KSPDev.ConfigUtils.PrimitiveTypesProto">
            <summary>A proto for handling C# primitive types.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.PrimitiveTypesProto.CanHandle(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.PrimitiveTypesProto.SerializeToString(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.PrimitiveTypesProto.ParseFromString(System.String,System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:KSPDev.ConfigUtils.StandardOrdinaryTypesProto">
            <summary>Proto to handle all primitive C# types and common Unity/KSP types.</summary>
            <seealso cref="T:KSPDev.ConfigUtils.PrimitiveTypesProto"/>
            <seealso cref="T:KSPDev.ConfigUtils.KspTypesProto"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.StandardOrdinaryTypesProto.CanHandle(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.StandardOrdinaryTypesProto.SerializeToString(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.StandardOrdinaryTypesProto.ParseFromString(System.String,System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:KSPDev.ConfigUtils.StdPersistentGroups">
            <summary>Group names that have special meaning.</summary>
            <seealso cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="F:KSPDev.ConfigUtils.StdPersistentGroups.Default">
            <summary>A public group that can be saved/loaded on every game scene.</summary>
            <remarks>By the contract any caller can save/load this group at any time. If class declares
            persistent fields with specific save/load logic then they need to have a group different from
            the default.</remarks>
        </member>
        <member name="T:KSPDev.ConfigUtils.ConfigAccessor">
            <summary>A service class that simplifies accessing configuration files.</summary>
            <remarks>This class provides a lot of useful methods to deal with values in game's configuration
            files. There are low level methods that deal with nodes and values, and there are high level
            methods that use metadata from the annotated fields.</remarks>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsDatabaseAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsFromFile(System.String,System.Type,System.Object,System.String,System.String)">
            <summary>Reads values of the annotated persistent fields from a config file.</summary>
            <param name="filePath">A relative or an absolute path to the file. It's resolved via
            <see cref="M:KSPDev.FSUtils.KspPaths.makePluginPath(System.String)"/>.</param>
            <param name="type">A type to load fields for.</param>
            <param name="instance">An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be loaded.</param>
            <param name="nodePath">An optional path in the file. All type's field will be read relative
            to this part.</param>
            <param name="group">A group tag (see <see cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>).</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsFromDatabase(System.String,System.Type,System.Object,System.String)">
            <summary>Reads values of the annotated persistent fields from a config file.</summary>
            <param name="nodePath">An absolute path in the database. No leading "/".</param>
            <param name="type">A type to load fields for.</param>
            <param name="instance">An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be loaded.</param>
            <param name="group">A group tag (see <see cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>).</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsFromNode(ConfigNode,System.Type,System.Object,System.String)">
            <summary>Reads values of the annotated persistent fields from a config node.</summary>
            <param name="node">A config node to read data from.</param>
            <param name="type">A type to load fields for.</param>
            <param name="instance">An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be loaded.</param>
            <param name="group">A group tag (see <see cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>).</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsInType(System.Type,System.Object,System.String)">
            <summary>
            Reads persistent fields from the config files specified by the class annotation.
            </summary>
            <param name="type">A type to load fields for.</param>
            <param name="instance">An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be loaded.</param>
            <param name="group">A group to load fields for. If <c>null</c> then all groups that are
            defined in the class annotation via <see cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/> will be
            loaded.</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsDatabaseAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.WriteFieldsIntoFile(System.String,System.Type,System.Object,System.String,System.Boolean,System.String)">
            <summary>Writes values of the annotated persistent fields into a file.</summary>
            <remarks>All persitent values are <b>added</b> into the file provided. I.e. if node had
            already had a value being persited then it either overwritten (ordinary fields) or extended
            (collection fields).</remarks>
            <param name="filePath">A relative or an absolute path to the file. It's resolved via
            <see cref="M:KSPDev.FSUtils.KspPaths.makePluginPath(System.String)"/>.</param>
            <param name="rootNodePath">A path to the node in the file where the data should be
            written. If the node already exsist it will be deleted.</param>
            <param name="type">A type to write fields for.</param>
            <param name="instance">An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be written.</param>
            <paramref name="rootNodePath"/> node will be updated in that file. Otherwise, a new file
            <param name="mergeMode">If <c>true</c> and the file already exists then only
            will be created.</param>
            <param name="group">A group tag (see <see cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>).</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.WriteFieldsIntoNode(ConfigNode,System.Type,System.Object,System.String)">
            <summary>Writes values of the annotated persistent fields into a config node.</summary>
            <remarks>All persitent values are <b>added</b> into the node provided. I.e. if node had
            already had a value being persited then it either overwritten (ordinary fields) or extended
            (collection fields).</remarks>
            <param name="node">A config node to write data into.</param>
            <param name="type">A type to write fields for.</param>
            <param name="instance">An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be written.</param>
            <param name="group">A group tag (see <see cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>).</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.WriteFieldsFromType(System.Type,System.Object,System.String)">
            <summary>
            Writes persistent fields into the config files specified by the class annotation.
            </summary>
            <remarks>Method updates the config file(s) by preserving top level nodes that are not
            specified as targets for the requested group.
            <para>Note, that fields cannot be writtent into database. Such annotations will be skipped
            during the save.</para>
            </remarks>
            <param name="type">A type to write fields for.</param>
            <param name="instance">An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be written.</param>
            <param name="group">A group to write fields for. If <c>null</c> then all groups that are
            defined in the class annotation via <see cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/> will be
            written.</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetValueByPath(ConfigNode,System.String)">
            <summary>Reads a value from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="path">A string path to the value. Path components should be separated by '/'
            symbol.</param>
            <returns>String value or <c>null</c> if path or value is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetValueByPath(ConfigNode,System.String[])">
            <summary>Reads a value from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <returns>String value or <c>null</c> if path or value is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetValuesByPath(ConfigNode,System.String)">
            <summary>Reads repeated values from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="path">A string path to the values. Path components should be separated by '/'
            symbol.</param>
            <returns>Array of string values or <c>null</c> if path is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetValuesByPath(ConfigNode,System.String[])">
            <summary>Reads repeated values from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <returns>Array of string values or <c>null</c> if path is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetNodeByPath(ConfigNode,System.String,System.Boolean)">
            <summary>Reads a node from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="path">A string path to the node. Path components should be separated by '/'
            symbol.</param>
            <param name="createIfMissing">If <c>true</c> than unknown nodes in the path will be
            created.</param>
            <returns>Config node or <c>null</c> if path or node is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetNodeByPath(ConfigNode,System.String[],System.Boolean)">
            <summary>Reads a node from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="createIfMissing">If <c>true</c> than unknown nodes in the path will be
            created.</param>
            <returns>Config node or <c>null</c> if path or node is not present in the
            <paramref name="node"/>. Returns <paramref name="node"/> if path is empty array.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetNodesByPath(ConfigNode,System.String)">
            <summary>Reads repeated nodes from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="path">A string path to the nodes. Path components should be separated by '/'
            symbol.</param>
            <returns>Array of nodes or <c>null</c> if path is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetNodesByPath(ConfigNode,System.String[])">
            <summary>Reads repeated nodes from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <returns>Array of nodes or <c>null</c> if path is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.SetValueByPath(ConfigNode,System.String,System.String)">
            <summary>Sets a value in config node by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="path">A string path to the node. Path components should be separated by '/'
            symbol.</param>
            <param name="value">A string value to store.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.SetValueByPath(ConfigNode,System.String[],System.String)">
            <summary>Sets a value in config node by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="value">A string value to store.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.SetNodeByPath(ConfigNode,System.String,ConfigNode)">
            <summary>Sets a node in config node by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="path">A string path to the node. Path components should be separated by '/'
            symbol.</param>
            <param name="value">A config node to store.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.SetNodeByPath(ConfigNode,System.String[],ConfigNode)">
            <summary>Sets a node in config node by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="value">A config node to store.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.AddValueByPath(ConfigNode,System.String,System.String)">
            <summary>Adds a repeated value in config node by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="path">A string path to the nodes. Path components should be separated by '/'
            symbol.</param>
            <param name="value">A string value to add into the node.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.AddValueByPath(ConfigNode,System.String[],System.String)">
            <summary>Adds a repeated value in config node by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="value">A string value to add into the node.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.AddNodeByPath(ConfigNode,System.String,ConfigNode)">
            <summary>Adds a repeated node in the config by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="path">A string path to the nodes. Path components should be separated by '/'
            symbol.</param>
            <param name="value">A config node to add.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.AddNodeByPath(ConfigNode,System.String[],ConfigNode)">
            <summary>Adds a repeated node in the config by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="value">A config node to add.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.SetValueByPath``1(ConfigNode,System.String,``0,KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto)">
            <summary>
            Stores a value of arbitrary type <typeparamref name="T"/> into a config node.
            </summary>
            <param name="node">A node to set data in.</param>
            <param name="path">A string path to the node. Path components should be separated by '/'
            symbol.</param>
            <param name="value">A value to store. The <paramref name="typeProto"/> handler must know how
            to convert the value into string.</param>
            <param name="typeProto">A proto capable to handle the type of <paramref name="value"/>. If not
            set then <see cref="T:KSPDev.ConfigUtils.StandardOrdinaryTypesProto"/> is used.</param>
            <typeparam name="T">The value type to store. Type proto must be able to handle it.
            </typeparam>
            <exception cref="T:System.ArgumentException">If type cannot be handled by the proto.</exception>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.SetValueByPath``1(ConfigNode,System.String[],``0,KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto)">
            <summary>
            Stores a value of arbitrary type <typeparamref name="T"/> into a config node.
            </summary>
            <param name="node">A node to set data in.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="value">A value to store. The <paramref name="typeProto"/> handler must know how
            to convert value's type into string.</param>
            <param name="typeProto">A proto capable to handle the type of <paramref name="value"/>. If not
            set then <see cref="T:KSPDev.ConfigUtils.StandardOrdinaryTypesProto"/> is used.</param>
            <typeparam name="T">The value type to store. Type proto must be able to handle it.
            </typeparam>
            <exception cref="T:System.ArgumentException">If type cannot be handled by the proto.</exception>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetValueByPath``1(ConfigNode,System.String,``0@,KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto)">
            <summary>
            Reads a value of arbitrary type <typeparamref name="T"/> from a config node.
            </summary>
            <param name="node">A node to read data from.</param>
            <param name="path">A string path to the node. Path components should be separated by '/'
            symbol.</param>
            <param name="value">A variable to read value into. The <paramref name="typeProto"/> handler
            must know how to convert value's type from string.</param>
            <param name="typeProto">A proto capable to handle the type of <paramref name="value"/>. If not
            set then <see cref="T:KSPDev.ConfigUtils.StandardOrdinaryTypesProto"/> is used.</param>
            <returns><c>true</c> if value was successfully read and stored.</returns>
            <typeparam name="T">The value type to read. Type proto must be able to handle it.
            </typeparam>
            <exception cref="T:System.ArgumentException">If type cannot be handled by the proto.</exception>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetValueByPath``1(ConfigNode,System.String[],``0@,KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto)">
            <summary>
            Reads a value of arbitrary type <typeparamref name="T"/> from a config node.
            </summary>
            <param name="node">A node to read data from.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="value">A variable to read value into. The <paramref name="typeProto"/> handler
            must know how to convert value's type from string.</param>
            <param name="typeProto">A proto capable to handle the type of <paramref name="value"/>. If not
            set then <see cref="T:KSPDev.ConfigUtils.StandardOrdinaryTypesProto"/> is used.</param>
            <returns><c>true</c> if value was successfully read and stored.</returns>
            <typeparam name="T">The value type to read. Type proto must be able to handle it.
            </typeparam>
            <exception cref="T:System.ArgumentException">If type cannot be handled by the proto.</exception>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetPersistentFieldsFiles(System.Type,System.String)">
            <summary>Gathers and returns persistent field fields annotations.</summary>
            <param name="type">A type to lookup for the field annotations.</param>
            <param name="group">A group tag (see <see cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>). If
            <c>null</c> then all files defined in the type are returned.</param>
            <returns>Array of persistent fields.</returns>
        </member>
        <member name="T:KSPDev.ConfigUtils.CollectionFieldHandler">
            <summary>A handler that manages collections in persitent fields.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.CollectionFieldHandler.#ctor(KSPDev.ConfigUtils.PersistentField,System.Type,System.Type)">
            <param name="persistentField">A descriptor of persistent field which holds the value.</param>
            <param name="collectionType">A type of the collection this handler will be handling.</param>
            <param name="collectionProtoType">A proto type that can work with the collection.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.CollectionFieldHandler.SerializeValues(ConfigNode,System.Object)">
            <summary>Stores collection values into a config node.</summary>
            <param name="node">A node to add values into.</param>
            <param name="value">A collection instance to get values from.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.CollectionFieldHandler.DeserializeValues(ConfigNode)">
            <summary>Creates a collection from the config node.</summary>
            <param name="node">A node to read data from.</param>
            <returns>Сollection instance.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.CollectionFieldHandler.GetItemType">
            <summary>Returns type of an item in the colelction.</summary>
            <returns>Item's type.</returns>
        </member>
        <member name="T:KSPDev.ConfigUtils.PersistentFieldsFactory">
            <summary>A helper class to gather persistent field attributes.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentFieldsFactory.GetPersistentFields(System.Type,System.Boolean,System.Boolean,System.String)">
            <summary>Gathers persitent fields for a type.</summary>
            <param name="type">A type of to gather persistent fields for.</param>
            <param name="needStatic">Specifies if static fields need to be returned.</param>
            <param name="needInstance">Specifies if non-static fields need to be returned.</param>
            <param name="group">A filter group for the persitent fields. Note that group is ignored for
            the inner fields of a compound type.</param>
            <returns>List of persitent fields.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentFieldsFactory.FindAnnotatedFields(System.Reflection.IReflect,System.Boolean,System.Boolean,System.String)">
            <summary>Finds and returns peristent fields of the requested group.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentFieldsFactory.FieldFilter(System.Reflection.ICustomAttributeProvider,System.String)">
            <summary>Filters only persitent fields of the required group.</summary>
        </member>
        <member name="T:KSPDev.ConfigUtils.PersistentField">
            <summary>Descriptor of a persitent field.</summary>
        </member>
        <member name="F:KSPDev.ConfigUtils.PersistentField.fieldInfo">
            <summary>Annotated fields metadata.</summary>
        </member>
        <member name="F:KSPDev.ConfigUtils.PersistentField.cfgPath">
            <summary>Parsed configuration paths.</summary>
        </member>
        <member name="F:KSPDev.ConfigUtils.PersistentField.ordinaryFieldHandler">
            <summary>Instance of ordianl field proto as specified in the annotation.</summary>
        </member>
        <member name="F:KSPDev.ConfigUtils.PersistentField.collectionFieldHandler">
            <summary>Instance of collection field proto as specified in the annotation.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentField.#ctor(System.Reflection.FieldInfo,KSPDev.ConfigUtils.PersistentFieldAttribute)">
            <param name="fieldInfo">An annotated field metadata.</param>
            <param name="fieldAttr">An annotation of the field.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentField.WriteToConfig(ConfigNode,System.Object)">
            <summary>Writes field into a config node.</summary>
            <param name="node">A node to write state to.</param>
            <param name="instance">An owner of the field. Can be <c>null</c> for static fields.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentField.ReadFromConfig(ConfigNode,System.Object)">
            <summary>Reads field from a config node.</summary>
            <param name="node">A node to read state from.</param>
            <param name="instance">An owner of the field. Can be <c>null</c> for static fields.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentField.SerializeCompoundFieldsToNode(System.Object)">
            <summary>Makes a config node from the compound type fields.</summary>
            <param name="instance">An owner ofthe fields. Can be <c>null</c> for static fields.</param>
            <returns>New configuration node with the data.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentField.DeserializeCompoundFieldsFromNode(ConfigNode,System.Object)">
            <summary>Sets compound type field values from the config node.</summary>
            <param name="node">A node to read values from.</param>
            <param name="instance">An owner ofthe fields. Can be <c>null</c> for static fields.</param>
        </member>
        <member name="T:KSPDev.ConfigUtils.PersistentFieldAttribute">
            <summary>A simple attribute for fields that need (de)serialization.</summary>
            <remarks>
            This form allows adjusting any <see cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/> property
            in the annotation, and has a shortcut to mark field as collection
            (<c><see cref="P:KSPDev.ConfigUtils.PersistentFieldAttribute.isCollection"/> = true</c>).
            <para> By default ordinal values are handled via <see cref="T:KSPDev.ConfigUtils.StandardOrdinaryTypesProto"/>
            and collection fields via <see cref="T:KSPDev.ConfigUtils.GenericCollectionTypeProto"/>. These proto handlers can
            be changed in the annotation by assigning values to properties
            <see cref="P:KSPDev.ConfigUtils.PersistentFieldAttribute.ordinaryTypeProto"/> and/or <see cref="P:KSPDev.ConfigUtils.PersistentFieldAttribute.collectionTypeProto"/>.</para>
            </remarks>
            <example>
            Below is a simple usage of the attribute.
            <code>
            class ClassWithPersistentFields {
              [PersistentField("my/listField", isCollection = true)]
              private List&lt;string&gt; sampleList = new List&lt;string&gt;();
            
              internal struct ComplexType {
                [PersistentField("val1", group = "nevermind")]
                public bool boolVal;
                [PersistentField("val2")]
                public Color colorVal;
              }
            
              [PersistentField("my/setField", isCollection = true, group = "abc")]
              private HashSet&lt;ComplexType&gt; sampleSet = new HashSet&lt;ComplexType&gt;();
            
              void SaveConfigs() {
                // Save a default group of fields: only field "sampleList" qualifies.
                ConfigAccessor.WriteFieldsIntoFile("settings.cfg", instance: this);
                /* The following structure in the file will be created:
                 * {
                 *   my
                 *   {
                 *     listField: string1
                 *     listField: string2
                 *   }
                 * }
                 */
            
                // Save a specific group of fields: only field "sampleSet" belongs to group "abc".
                sampleSet.Add(new ComplexType() { boolVal = true, colorVal = Color.black });
                sampleSet.Add(new ComplexType() { boolVal = false, colorVal = Color.white });
                ConfigAccessor.WriteFieldsIntoFile("settings.cfg", instance: this, group: "abc");
                /* The following structure in the file will be created:
                 * {
                 *     setField
                 *     {
                 *       val1: True
                 *       val2: 0,0,0,1
                 *     }
                 *     setField
                 *     {
                 *       val1: false
                 *       val2: 1,1,1,1
                 *     }
                 *   }
                 * }
                 */
              }
            }
            </code>
            <para>Note that group is ignored in the nested types. I.e. in <c>ComplexType</c> in this case.
            Though, if <c>ComplexType</c> was an immediate target of the <c>WriteFieldsIntoFile</c> call
            then the group would be considered.</para>
            <para>Visibility of the annotated field is also important. Persistent field attributes are
            only visible in the child class if they were public or protected in the parent. Private field
            annotations are not inherited and need to be handled at the level of the declaring class.
            </para>
            <code>
            class Parent {
              [PersistentField("parent_private")]
              private int field1 = 1;
            
              [PersistentField("parent_protected")]
              protected int field2 = 2;
            
              [PersistentField("parent_public")]
              public int field3 = 3;
            }
            
            class Child : Parent {
              [PersistentField("child_private")]
              private int field1 = 10;
            
              void SaveConfig() {
                // Save all fields in the inherited type. 
                ConfigAccessor.WriteFieldsIntoFile("settings.cfg", instance: this);
                /* The following structure in the file will be created:
                 * {
                 *     parent_protected: 2
                 *     parent_public: 3
                 *     child_private: 10
                 * }
                 */
            
                // Save all fields in the base type. 
                ConfigAccessor.WriteFieldsIntoFile("settings.cfg", instance: (Parent) this);
                /* The following structure in the file will be created:
                 * {
                 *     parent_private: 1
                 *     parent_protected: 2
                 *     parent_public: 3
                 * }
                 */
              }
            }
            </code>
            <para>The code above implies that in a common case unsealed class should put private fields in
            a group other than default to avoid settings collision.</para> 
            <para>When type of the field is different from primitive C# type or common Unity 4 type you
            may need provide custom value handlers to deal with (de)serializing. E.g. for an ordinary type
            it may look like this:</para>
            <code>
            class CustomTypes {
              [PersistentField("my/custom/type", ordinaryTypeProto = typeof(MyTypeProto))]
              private MyType field1;
            }
            </code>
            <para>If your custom type is a collection that cannot be handled by the standard proto you can
            provide your own collection proto handler. Note that if you do the annotated field will be
            treated as a collection. In fact, when you set <c>isCollection = true</c> what actually
            happens is just assigning <see cref="T:KSPDev.ConfigUtils.GenericCollectionTypeProto"/> as a collection proto
            handler.</para>
            <code>
            class CustomTypes {
              [PersistentField("my/custom/type", collectionTypeProto = typeof(MyCollectionProto))]
              private MyCollection field1;
            }
            </code>
            For more examples on custom proto handlers see <see cref="T:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto"/> and
            <see cref="T:KSPDev.ConfigUtils.AbstractCollectionTypeProto"/>.
            </example>
            <seealso cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
            <seealso cref="T:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto"/>
            <seealso cref="T:KSPDev.ConfigUtils.AbstractCollectionTypeProto"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentFieldAttribute.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:KSPDev.ConfigUtils.PersistentFieldAttribute.ordinaryTypeProto">
            <summary>A proto for handling the annotated field.</summary>
            <remarks>If field is a collection then this proto will be used to handle values of the
            collection items.</remarks>
        </member>
        <member name="P:KSPDev.ConfigUtils.PersistentFieldAttribute.collectionTypeProto">
            <summary>A proto for handling collection fields.</summary>
            <remarks>If this property is not <c>null</c> than the annotated field is trreated as a
            collection of values.</remarks>
        </member>
        <member name="P:KSPDev.ConfigUtils.PersistentFieldAttribute.isCollection">
            <summary>Specifies if the annotated field is a collection of values.</summary>
        </member>
        <member name="T:KSPDev.ConfigUtils.KspTypesProto">
            <summary>A proto for handling all KSP specific types.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.KspTypesProto.CanHandle(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.KspTypesProto.SerializeToString(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.KspTypesProto.ParseFromString(System.String,System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:KSPDev.Extensions.Dictionaries">
            <summary>Helper extensions for generic dictionary container.</summary>
        </member>
        <member name="M:KSPDev.Extensions.Dictionaries.SetDefault``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            Returns a value from dictionary by the key. If key is not defined yet then a new default entry
            is created and returned.
            </summary>
            <example>
            It's most useful when dealing with dictionaries of a complex type:
            <code><![CDATA[
            var a = new Dictionary<int, HashSet<string>>();
            // An empty string set for key 1 is created, and "abc" is added in it.
            a.SetDefault(1).Add("abc");
            // "def" is added into existing string set at key 1. 
            a.SetDefault(1).Add("def");
            ]]></code>
            </example>
            <param name="dict">Dictionary to get value from.</param>
            <param name="key">Key to lookup.</param>
            <typeparam name="K">Type of the dictionary key.</typeparam>
            <typeparam name="V">Type of the dictionary value.</typeparam>
            <returns>Either an existing value for the key or a default instance of the value.</returns>
        </member>
        <member name="T:KSPDev.FSUtils.KspPaths">
            <summary>A helper class to deal with plugins file structure.</summary>
        </member>
        <member name="F:KSPDev.FSUtils.KspPaths.pluginsRootFolder">
            <summary>Standard plug-ins folder.</summary>
        </member>
        <member name="M:KSPDev.FSUtils.KspPaths.makePluginPath(System.String)">
            <summary>Makes an absolute file path given a relative one.</summary>
            <param name="path">A relative or an absolute part. If the first case the path is translated
            from the game's plugin root folder ("GameData" as of KSP 1.0.5). If argument is an absolute
            path then it's returned as is.</param>
            <returns>Absolute file path.</returns>
        </member>
        <member name="P:KSPDev.FSUtils.KspPaths.pluginsRoot">
            <summary>Returns full path to the plugins root folder.</summary>
        </member>
        <member name="T:KSPDev.GUIUtils.Formatter">
            <summary>Helper to format various values.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.Formatter.SpecialValue(System.Single,System.String,System.Single,System.String)">
            <summary>Formats float number that has special meaning for a predefined value.</summary>
            <param name="number">Number to format.</param>
            <param name="fmt">Format string for the number.</param>
            <param name="specialValue">Special value of the number.</param>
            <param name="specialString">String to show for the special value.</param>
            <returns>Formatted string.</returns>
            <example>
            <code><![CDATA[
            var fmt = "Value: {0}";
            var spcFmt = "SPECIAL VALUE!";
            Debug.LogFormat(Formatter.SpecialValue(0.5f, fmt, 0.5f, spcFmt);
            // Outputs:
            // SPECIAL VALUE!
            Debug.LogFormat(Formatter.SpecialValue(0.4f, fmt, 0.5f, spcFmt);
            // Outputs:
            // Value: 0.4
            ]]></code>
            </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Formatter.SpecialValue(System.Int32,System.String,System.Int32,System.String)">
            <summary>Formats integer number that has special meaning for a predefined value.</summary>
            <param name="number">Number to format.</param>
            <param name="fmt">Format string for the number.</param>
            <param name="specialValue">Special value of the number.</param>
            <param name="specialString">String to show for the special value.</param>
            <returns>Formatted string.</returns>
            <example>
            <code><![CDATA[
            var fmt = "Value: {0}";
            var spcFmt = "SPECIAL VALUE!";
            Debug.Log(Formatter.SpecialValue(100, fmt, 100, spcFmt);
            // Outputs:
            // SPECIAL VALUE!
            Debug.Log(Formatter.SpecialValue(101, fmt, 100, spcFmt);
            // Outputs:
            // Value: 101
            ]]></code>
            </example>
        </member>
        <member name="T:KSPDev.GUIUtils.MessageBoolValue">
             <summary>A class to wrap a UI string for a boolean value.</summary>
             <remarks>
             <para>
             When string needs to be presented use <see cref="M:KSPDev.GUIUtils.MessageBoolValue.Format(System.Boolean)"/> to make the parameter substitute.
             </para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>MessageBoolValue</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               static readonly MessageBoolValue SwitchMsg = new MessageBoolValue("ON", "OFF");
               static readonly MessageBoolValue StateMsg = new MessageBoolValue("Enabled", "Disabled");
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", SwitchMsg.Format(true));  // ON
                 Debug.LogFormat("Localized: {0}", StateMsg.Format(false));  // Disabled
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageBoolValue.#ctor(System.String,System.String)">
            <summary>Creates a message.</summary>
            <param name="positiveStr">Message string for <c>true</c> value.</param>
            <param name="negativeStr">Message string for <c>false</c> value.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageBoolValue.Format(System.Boolean)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.MessageEnumValue`1">
             <summary>A class to wrap a UI string for an enum value.</summary>
             <remarks>
             <para>
             When string needs to be presented use <see cref="M:KSPDev.GUIUtils.MessageEnumValue`1.Format(`0)"/> to make the parameter substitute.
             </para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of doing switches when an enum value should be presented on UI just define a message
             that declares a map between values and their UI representations. You don't need specify every
             single value in the map, there is an option to set a UI string for unknown value.  
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               enum MyEnum {
                 Disabled,
                 Enabled,
                 UnusedValue1,
                 UnusedValue2,
                 UnusedValue3,
               }
            
               // Lookup with custom value for an unknown key.
               static readonly MessageEnumValue<MyEnum> Msg1 =
                   new MessageEnumValue<MyEnum>("UNKNOWN") {
                     {MyEnum.Enabled, "ENABLED"},
                     {MyEnum.Disabled, "DISABLED"},
                   };
            
               // Default lookup.
               static readonly MessageEnumValue<MyEnum> Msg2 =
                   new MessageEnumValue<MyEnum>() {
                     {MyEnum.Enabled, "ENABLED"},
                     {MyEnum.Disabled, "DISABLED"},
                     {MyEnum.UnusedValue1, "Value1"},
                     {MyEnum.UnusedValue2, "Value2"},
                   };
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", Msg1.Format(MyEnum.Disabled));  // DISABLED
                 Debug.LogFormat("Localized: {0}", Msg1.Format(MyEnum.UnusedValue1));  // UNKNOWN
            
                 Debug.LogFormat("Localized: {0}", Msg2.Format(MyEnum.UnusedValue1));  // Value1
                 Debug.LogFormat("Localized: {0}", Msg2.Format(MyEnum.UnusedValue2));  // Value2
                 Debug.LogFormat("Localized: {0}", Msg2.Format(MyEnum.UnusedValue3));  // "" (null)
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageEnumValue`1.#ctor(System.String)">
            <summary>Creates an empty message with a default value for unknow entries.</summary>
            <param name="unknownKeyValue">
            Value to return if lookup dictionary doesn't have the requested key.
            </param>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageEnumValue`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageEnumValue`1.Add(`0,System.String)">
            <summary>Adds a new lookup for the key.</summary>
            <param name="key">Unique key.</param>
            <param name="value">GUI string for the key.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageEnumValue`1.Format(`0)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.MessageSpecialFloatValue">
             <summary>
             A class to wrap a UI string with one parameter which may have special meaning.
             </summary>
             <remarks>
             <para>When string needs to be presented use <see cref="M:KSPDev.GUIUtils.MessageSpecialFloatValue.Format(System.Single)"/> to make the parameter
             substitute.</para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               MessageSpecialFloatValue MyMessage =
                   new MessageSpecialFloatValue("Param: {0}", 0, "Param is ZERO");
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage.Format(1));  // Param: 1
                 Debug.LogFormat("Localized: {0}", MyMessage.Format(0));  // Param is ZERO
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageSpecialFloatValue.#ctor(System.String,System.Single,System.String)">
            <summary>Creates a message.</summary>
            <param name="fmtString">A message format string.</param>
            <param name="specialValue">Value to use a special message string for.</param>
            <param name="specialString">Special message string for the value.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageSpecialFloatValue.Format(System.Single)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.ScreenMessaging">
            <summary>Helper class to present global UI messages.</summary>
            <remarks>The actual representation of the different priority messages depends on the KSP
            version. As a rule of thumb use the following reasons when deciding how to show a message:
            <list>
            <item>Important messages should be show as "priority". It's assumed that UI layout is build so
                what that such messages won't be missed.</item>
            <item>Messages that only give status update and can be safely ignored by the player should be
                reported as "info". They will show up in UI but not necessarily bring user's attention.
                </item>
            </list>
            </remarks>
            <example>
            <code>
            class MyMod : MonoBehaviour {
              void Update() {
                if (Input.GetKeyDown("1")) {
                  ScreenMessaging.ShowPriorityScreenMessage("Key pressed in frame #{0}", Time.frameCount);
                }
              }
            }
            </code>
            </example>
        </member>
        <member name="F:KSPDev.GUIUtils.ScreenMessaging.DefaultMessageTimeout">
            <summary>Default timeout for a regular UI message.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.ScreenMessaging.DefaultErrorTimeout">
            <summary>Default timeout for a UI message that reports an error.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.ScreenMessaging.DefaultWarningTimeout">
            <summary>Default timeout for a UI message that warns about unusual conditions.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.ScreenMessaging.ErrorColor">
            <summary>Default color for the error messages.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.ScreenMessaging.WarningColor">
            <summary>Default color for the warning messages.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.SetColorToRichText(System.String,UnityEngine.Color)">
            <summary>Wraps string into Unity rich-text tags to set a color.</summary>
            <remarks>Note, that Unity rich-text is not the same as RTF specification.</remarks>
            <param name="str">String to wrap.</param>
            <param name="color">Color to apply to the string.</param>
            <returns>Unity rich-text string.</returns>
            <seealso href="https://docs.unity3d.com/Manual/StyledText.html">
            Unity 3D: Rich-Text styled text</seealso>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowScreenMessage(ScreenMessageStyle,System.Single,System.String,System.Object[])">
            <summary>Shows a formatted message with the specified location and timeout.</summary>
            <param name="style">A <c>ScreenMessageStyle</c> specifier.</param>
            <param name="duration">Delay before hiding the message in seconds.</param>
            <param name="fmt"><c>string.Format()</c> formatting string.</param>
            <param name="args">Arguments for the formattign string.</param>
            <seealso href="https://kerbalspaceprogram.com/api/class_screen_messages.html">
            KSP: ScreenMessages</seealso>
            <seealso href="https://kerbalspaceprogram.com/api/_screen_messages_8cs.html#ac19a4c3800d327889475848ccbbf9317">
            KSP: ScreenMessageStyle</seealso>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowScreenMessage(ScreenMessageStyle,System.Single,UnityEngine.Color,System.String,System.Object[])">
            <summary>Shows a formatted message with the specified location and timeout.</summary>
            <param name="style"><see cref="T:ScreenMessageStyle"/> specifier.</param>
            <param name="duration">Delay before hiding the message in seconds.</param>
            <param name="color">Color to apply on the string.</param>
            <param name="fmt"><c>string.Format()</c> formatting string.</param>
            <param name="args">Arguments for the formattign string.</param>
            <seealso href="https://kerbalspaceprogram.com/api/class_screen_messages.html">
            KSP: ScreenMessages</seealso>
            <seealso href="https://kerbalspaceprogram.com/api/_screen_messages_8cs.html#ac19a4c3800d327889475848ccbbf9317">
            KSP: ScreenMessageStyle</seealso>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowPriorityScreenMessageWithTimeout(System.Single,System.String,System.Object[])">
            <summary>Shows an important message with the specified timeout.</summary>
            <remarks>It's no defined how exactly the message is shown. The only thing required is that
            player won't miss it.</remarks>
            <param name="duration">Delay before hiding the message in seconds.</param>
            <param name="fmt">A formatting string.</param>
            <param name="args">Arguments for the formatting string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowPriorityScreenMessage(System.String,System.Object[])">
            <summary>Shows an important message with a default timeout.</summary>
            <remarks>It's no defined how exactly the message is shown. The only thing required is that
            player won't miss it.</remarks>
            <param name="fmt">A formatting string.</param>
            <param name="args">Arguments for the formatting string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowInfoScreenMessageWithTimeout(System.Single,System.String,System.Object[])">
            <summary>Shows an info message with the specified timeout.</summary>
            <remarks>It's no defined how exactly the message is shown.</remarks>
            <param name="duration">Delay before hiding the message in seconds.</param>
            <param name="fmt"><c>string.Format()</c> formatting string.</param>
            <param name="args">Arguments for the formattign string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowInfoScreenMessage(System.String,System.Object[])">
            <summary>Shows an info message with a default timeout.</summary>
            <remarks>It's no defined how exactly the message is shown.</remarks>
            <param name="fmt"><c>string.Format()</c> formatting string.</param>
            <param name="args">Arguments for the formattign string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowErrorScreenMessage(System.String,System.Object[])">
            <summary>Shows an error message with a default timeout.</summary>
            <remarks>
            It's no defined how exactly the message is shown, but it's guaranteed it looks like an error
            and player will perceive it like that.
            </remarks>
            <param name="fmt"><c>string.Format()</c> formatting string.</param>
            <param name="args">Arguments for the formattign string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowWarningScreenMessage(System.String,System.Object[])">
            <summary>Shows a warning message with a default timeout.</summary>
            <remarks>
            It's no defined how exactly the message is shown, but it's guaranteed it looks like an error
            and player will perceive it like that.
            </remarks>
            <param name="fmt"><c>string.Format()</c> formatting string.</param>
            <param name="args">Arguments for the formattign string.</param>
        </member>
        <member name="T:KSPDev.GUIUtils.HintOverlay">
             <summary>A wrapper class to present simple overlay window with text.</summary>
             <remarks>
             <para>Overlay windows doesn't have border or title. Main purpose of such windows is "hints".
             I.e. short lived piece of information presented for the current context. The hint won't be shown
             in UI until explicitly requsted via call to a <c>ShowAt*</c> method.</para>
             <para>Keep in mind that this window contains graphics objects that will be destroyed on scene
             re-loading. I.e. it must be re-created on every scene change.</para>
             </remarks>
             <example>
             In a common case initialization of the hint window is done on the game object awakening, and
             it's either shown or hidden in <c>OnGUI</c> method.
             <code>
             class MyMod : MonoBehaviour {
               HintOverlay hint;
            
               void Awake() {
                 hint = new HintOverlay(12, 3, Color.white, new Color(0f, 0f, 0f, 0.5f));
               }
            
               void OnGUI() {
                 hint.text = string.Format("Current frame is: {0}", Time.frameCount);
                 hint.ShowAtCursor();
               }
             }
             </code>
             <para>In the example above text of the hint is set on every frame update since frame count is updated
             this frequently. Though, if your data is updated less frequently you may save some performance
             by updating text in the methods different from <c>OnGUI</c>.</para>
             </example>
        </member>
        <member name="F:KSPDev.GUIUtils.HintOverlay.BackgroundTextureSize">
            <summary>Size of the sample texture that fills hint window backgroud.</summary>
            <remarks>Small values may impact rendering performance. Large values will increase memory
            footpring. Choose it wise.</remarks>
        </member>
        <member name="F:KSPDev.GUIUtils.HintOverlay.RightSideMousePadding">
            <summary>Padding when showing hint on the right side of the mouse cursor.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.HintOverlay.LeftSideMousePadding">
            <summary>Padding when showing hint on the left side of the mouse cursor.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.HintOverlay.textSize">
            <summary>Precalculated UI text size for the currently assigned text.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.HintOverlay.hintWindowStyle">
            <summary>Precalculated style for the hint overlay window.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.HintOverlay.#ctor(System.Int32,System.Int32,UnityEngine.Color,UnityEngine.Color)">
            <summary>Constructs an overaly.</summary>
            <param name="fontSize">Size of the text font in the hint.</param>
            <param name="padding">Padding between the text and the window boundaries.</param>
            <param name="textColor">Color of the hint text.</param>
            <param name="backgroundColor">Color of the hint background. If alpha component is different
            from <c>1.0</c> then background will be semi-transparent.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.HintOverlay.ShowAtCursor">
            <summary>Shows hint text at the current mouse pointer.</summary>
            <remarks>When possible the window is shown on the right side of the cursor. Though, if part of
            the window goes out of the screen then it will be shown on the left side. If bottom boundary
            of the window hits bottom boundary of the screen then hint is aligned vertically so what the
            full content is visible. </remarks>
        </member>
        <member name="M:KSPDev.GUIUtils.HintOverlay.ShowAtPosition(System.Single,System.Single)">
            <summary>Shows hint at the absolute screen position.</summary>
            <remarks>If hint content goes out of the screen it's clipped.</remarks>
            <param name="x">X position is screen coordinates.</param>
            <param name="y">Y position is screen coordinates.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.HintOverlay.CreateSampleTextureFromColor(UnityEngine.Color)">
            <summary>Creates a clear color texture to fill background with.</summary>
            <param name="color">A background color.</param>
            <returns>Texture of a default size.</returns>
        </member>
        <member name="P:KSPDev.GUIUtils.HintOverlay.text">
            <summary>The hint overlay text.</summary>
            <remarks>Linefeed symbols are correctly handled. Use them to make multiline content. Setting
            text is an expensive operation since it results in window size recalculation. Don't update it
            more frequently than the underlaying data does.</remarks>
        </member>
        <member name="T:KSPDev.GUIUtils.Message">
             <summary>A class to wrap a simple UI string.</summary>
             <remarks>
             <para>Messages of this type don't have parameters and can be just casted to a string.</para> 
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               Message MyMessage = "This is a message without parameters";
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage);
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Message.#ctor(System.String)">
            <summary>Creates a message.</summary>
            <param name="messageString">A message string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.Message.op_Implicit(System.String)~KSPDev.GUIUtils.Message">
            <summary>Allows casting string to message.</summary>
            <remarks>Instead of creating new insatnce for every string just do the cast as it was a
            regular literal constant.</remarks>
            <param name="messageString">A string value to assign.</param>
            <returns>Message instance.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.Message.op_Implicit(KSPDev.GUIUtils.Message)~System.String">
            <summary>Allows casting messages to string.</summary>
            <param name="msg">A message to cast.</param>
            <returns>Message value.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.Message`1">
             <summary>A class to wrap a UI string with one parameter.</summary>
             <typeparam name="T1">Type of the first substitute argument in the string.</typeparam>
             <remarks>
             <para>Define parameter type via generic argument. When string needs to be presented use
             <see cref="M:KSPDev.GUIUtils.Message`1.Format(`0)"/> to make the parameter substitute.</para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               Message<string> MyMessage = "Param: {0}";
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage.Format("Blah!"));
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`1.#ctor(System.String)">
            <summary>Creates a message.</summary>
            <param name="fmtString">A message format string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`1.Format(`0)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`1.op_Implicit(System.String)~KSPDev.GUIUtils.Message{`0}">
            <summary>Allows casting strings to message.</summary>
            <param name="fmtString">A string value to assign.</param>
            <returns>Message instance.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.Message`2">
             <summary>A class to wrap a UI string with two parameters.</summary>
             <typeparam name="T1">Type of the first substitute argument in the string.</typeparam>
             <typeparam name="T2">Type of the second substitute argument in the string.</typeparam>
             <remarks>
             <para>Define parameter types via generic argument. When string needs to be presented use
             <see cref="M:KSPDev.GUIUtils.Message`2.Format(`0,`1)"/> to make parameters substitute.</para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               Message<string, int> MyMessage = "Params: {0}, {1}";
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage.Format("Blah!", 123));
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`2.#ctor(System.String)">
            <summary>Creates a message.</summary>
            <param name="fmtString">A message format string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`2.Format(`0,`1)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <param name="arg2">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`2.op_Implicit(System.String)~KSPDev.GUIUtils.Message{`0,`1}">
            <summary>Allows casting strings to message.</summary>
            <param name="fmtString">A string value to assign.</param>
            <returns>Message instance.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.Message`3">
             <summary>A class to wrap a UI string with three parameters.</summary>
             <typeparam name="T1">Type of the first substitute argument in the string.</typeparam>
             <typeparam name="T2">Type of the second substitute argument in the string.</typeparam>
             <typeparam name="T3">Type of the third substitute argument in the string.</typeparam>
             <remarks>
             <para>Define parameter types via generic argument. When string needs to be presented use
             <see cref="M:KSPDev.GUIUtils.Message`3.Format(`0,`1,`2)"/> to make parameters substitute.</para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               Message<string, int, float> MyMessage = "Params: {0}, {1}, {2}";
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage.Format("Blah!", 123, 321f));
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`3.#ctor(System.String)">
            <summary>Creates a message.</summary>
            <param name="fmtString">A message format string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`3.Format(`0,`1,`2)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <param name="arg2">An argument to substitute.</param>
            <param name="arg3">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`3.op_Implicit(System.String)~KSPDev.GUIUtils.Message{`0,`1,`2}">
            <summary>Allows casting strings to message.</summary>
            <param name="fmtString">A string value to assign.</param>
            <returns>Message instance.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.Message`4">
             <summary>A class to wrap a UI string with four parameters.</summary>
             <typeparam name="T1">Type of the first substitute argument in the string.</typeparam>
             <typeparam name="T2">Type of the second substitute argument in the string.</typeparam>
             <typeparam name="T3">Type of the third substitute argument in the string.</typeparam>
             <typeparam name="T4">Type of the fourth substitute argument in the string.</typeparam>
             <remarks>
             <para>Define parameter types via generic argument. When string needs to be presented use
             <see cref="M:KSPDev.GUIUtils.Message`4.Format(`0,`1,`2,`3)"/> to make parameters substitute.</para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               Message<string, int, float, int> MyMessage = "Params: {0}, {1}, {2}, {3}";
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage.Format("Blah!", 123, 321f, 456));
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`4.#ctor(System.String)">
            <summary>Creates a message.</summary>
            <param name="fmtString">A message format string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`4.Format(`0,`1,`2,`3)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <param name="arg2">An argument to substitute.</param>
            <param name="arg3">An argument to substitute.</param>
            <param name="arg4">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`4.op_Implicit(System.String)~KSPDev.GUIUtils.Message{`0,`1,`2,`3}">
            <summary>Allows casting strings to message.</summary>
            <param name="fmtString">A string value to assign.</param>
            <returns>Message instance.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.Message`5">
             <summary>A class to wrap a UI string with five parameters.</summary>
             <typeparam name="T1">Type of the first substitute argument in the string.</typeparam>
             <typeparam name="T2">Type of the second substitute argument in the string.</typeparam>
             <typeparam name="T3">Type of the third substitute argument in the string.</typeparam>
             <typeparam name="T4">Type of the fourth substitute argument in the string.</typeparam>
             <typeparam name="T5">Type of the fifth substitute argument in the string.</typeparam>
             <remarks>
             <para>Define parameter types via generic argument. When string needs to be presented use
             <see cref="M:KSPDev.GUIUtils.Message`5.Format(`0,`1,`2,`3,`4)"/> to make parameters substitute.</para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               Message<string, int, float, int, float> MyMessage = "Params: {0}, {1}, {2}, {3}, {4}";
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage.Format("Blah!", 123, 321f, 456, 456f));
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`5.#ctor(System.String)">
            <summary>Creates a message.</summary>
            <param name="fmtString">A message format string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`5.Format(`0,`1,`2,`3,`4)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <param name="arg2">An argument to substitute.</param>
            <param name="arg3">An argument to substitute.</param>
            <param name="arg4">An argument to substitute.</param>
            <param name="arg5">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`5.op_Implicit(System.String)~KSPDev.GUIUtils.Message{`0,`1,`2,`3,`4}">
            <summary>Allows casting strings to message.</summary>
            <param name="fmtString">A string value to assign.</param>
            <returns>Message instance.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.KeyModifiers">
            <summary>Flags to specify key modifiers combination.</summary>
            <remarks>Modifiers can be joined to get a combination. E.g. <c>AnyAlt | AnyShift</c>.</remarks>
            <seealso cref="M:KSPDev.GUIUtils.EventChecker.IsModifierCombinationPressed(KSPDev.GUIUtils.KeyModifiers)"/>
        </member>
        <member name="F:KSPDev.GUIUtils.KeyModifiers.None">
            <summary>No modifier keys are pressed.</summary>
            <remarks>This value only makes sense when used alone. Combining it with any other value
            will result in ignoring value <c>None</c>.</remarks>
        </member>
        <member name="F:KSPDev.GUIUtils.KeyModifiers.AnyAlt">
            <summary>Left or right ALT key pressed.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.KeyModifiers.AnyShift">
            <summary>Left or right SHIFT key pressed.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.KeyModifiers.AnyControl">
            <summary>Left or right CONTROL key pressed.</summary>
        </member>
        <member name="T:KSPDev.GUIUtils.EventChecker">
            <summary>A helper to verify various event handling conditions.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.EventChecker.IsModifierCombinationPressed(KSPDev.GUIUtils.KeyModifiers)">
            <summary>Verifies that the requested key modifiers are pressed.</summary>
            <remarks>The check will succeed only if the exact set of modifier keys is pressed. If there
            are more or less modifiers pressed the check will fail. E.g. if there are <c>LeftAlt</c> and
            <c>LeftShift</c> pressed but the check is executed against
            <c>AnyShift</c> then it will fail. Though, checking for <c>AnyShift | AnyAlt</c> will succeed.
            <para>In case of checking for <c>None</c> the check will require no modifier keys to be
            pressed. If you deal with mouse button events it's a good idea to verify if no modifiers are
            pressed even if you don't care about other combinations. It will let other modders to use
            mouse buttons and not to interfere with your mod.</para>
            </remarks>
            <param name="modifiers">A combination of key modifiers to verify.</param>
            <returns><c>true</c> when exactly the requested combination is pressed.</returns>
            <seealso cref="T:KSPDev.GUIUtils.KeyModifiers"/>
        </member>
        <member name="T:KSPDev.GUIUtils.GuiActionsList">
             <summary>A helper to accumulate GUI actions.</summary>
             <remarks>Unity may issue multiple GUI passes during a frame, and it requires number of UI
             elements not to change between the passes. Unity expects the number of UI
             controls in every pass to be exactly the same as in the very first one:
             <see href="http://docs.unity3d.com/ScriptReference/EventType.Layout.html">EventType.Layout</see>.
             When UI interactions affect representation all the changes must be postponed till the frame
             rendering is ended. This helper can be used to store actions that will be executed at the
             beginning of the next frame.</remarks>
             <example>
             <code>
             public class MyUI : MonoBehaviour {
               private readonly GuiActionsList guiActions = new GuiActionsList();
               private bool showLabel = false;
            
               void OnGUI() {
                 if (guiActions.ExecutePendingGuiActions()) {
                   // ...do other stuff that affects UI... 
                 }
            
                 if (GUILayout.Button(new GUIContent("Test Button"))) {
                   // If "showLabel" is changed right here then Unity GUI will complain saying the number
                   // of UI controls has changed. So, postpone the change until current frame is ended.
                   guiActions.Add(() => {
                     showLabel = !showLabel;  // This will be done at the beginning of the next frame.
                   });
                 }
                 
                 if (showLabel) {
                   GUILayout.Label("Test label");
                 }
               }
             }
             </code>
             <para>If you were using simple approach and updated <c>showLabel</c> right away Unity would
             likely thrown an error like this:</para>
             <para><c>[EXCEPTION] ArgumentException: Getting control 1's position in a group with only 1
             controls when doing Repaint</c></para>
             <seealso href="http://docs.unity3d.com/Manual/GUIScriptingGuide.html"/>
             <seealso href="http://docs.unity3d.com/ScriptReference/EventType.html"/>
             </example>
        </member>
        <member name="F:KSPDev.GUIUtils.GuiActionsList.guiActions">
            <summary>A list of pending actions.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.GuiActionsList.Add(KSPDev.GUIUtils.GuiActionsList.GuiAction)">
            <summary>Adds an action to the pending list.</summary>
            <param name="actionFn">An action callback.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.GuiActionsList.ExecutePendingGuiActions">
            <summary>Executes actions when it's safe to do the changes.</summary>
            <remarks>It's safe to call this method in every pass. It will detect when it's safe to apply
            the changes and apply the changes only once per a frame.</remarks>
            <returns><c>true</c> if actions have been applied.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.GuiActionsList.GuiAction">
            <summary>GUI action type.</summary>
        </member>
        <member name="T:KSPDev.GUIUtils.UISoundPlayer">
             <summary>Helper class to play sounds in game GUI. Such sounds are not 3D aligned.</summary>
             <remarks>
             Use this player when soucre of the sound is player keyboard actions or a mouse pointer. This
             class implements all the boilerplate to load and play sound resources.
             </remarks>
             <example>
             Here is an example of playing two different sounds on pressing "O" or "P" keys.
             <code><![CDATA[
             class MyModule : PartModule {
               public override OnAwake() {
                 // We don't want to loose latency on "ooo.ogg" playing.
                 UISoundPlayer.instance.CacheSound("ooo.ogg");
               }
            
               public override OnUpdate() {
                 if (Input.GetKeyDown("O")) {
                   UISoundPlayer.instance.Play("ooo.ogg");  // Played from cache. No delay.
                 }
                 if (Input.GetKeyDown("P")) {
                   UISoundPlayer.instance.Play("ppp.ogg");  // May delay game while loading the resource.
                 }
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="F:KSPDev.GUIUtils.UISoundPlayer.instance">
            <summary>Returns instance for the current scene.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.UISoundPlayer.audioCache">
            <summary>Global scene cache for all the sounds.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.UISoundPlayer.Play(System.String,System.Boolean)">
            <summary>Plays the specified sound.</summary>
            <remarks>
            Every request is cached unless requested otherwise. Subsequent calls to the play method won't
            require audio clip loading.
            </remarks>
            <param name="audioPath">File path relative to <c>GameData</c>.</param>
            <param name="dontCache">If <c>true</c> then audio will not be cached.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.UISoundPlayer.CacheSound(System.String)">
            <summary>Loads the sound into cache but doesn't play it.</summary>
            <remarks>
            Use this method when sound is expected to frequently played in the scene. If it worth spending
            a bit more time in the loading to win some latency during the play time then it pre-caching
            sounds is a good idea.
            </remarks>
            <param name="audioPath">File path relative to <c>GameData</c>.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.UISoundPlayer.Awake">
            <summary>Initializes <see cref="F:KSPDev.GUIUtils.UISoundPlayer.instance"/>.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.UISoundPlayer.GetOrLoadAudio(System.String,System.Boolean)">
            <summary>Loads audio sample and plays it.</summary>
            <param name="audioPath">File path relative to <c>GameData</c>.</param>
            <param name="dontCache">If <c>true</c> then audio will not be cached.</param>
            <returns>Audio resource if loaded or found in the cache, otherwise <c>null</c>.</returns>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IJointEventsListener">
            <summary>Declares callbacks that are called when a joint between two parts is changed.</summary>
            <remarks>
            Events of this inteface are triggered by Unity engine via reflections. It's not required for the
            module to implement the interface to be notified but by implementing it the code becomes more
            consistent and less error prone.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IJointEventsListener {
              /// <inheritdoc/>
              public void OnJointBreak(float breakForce) {
                Debug.LogInfoFormat("OnJointBreak: {0}", breakForce);
              }
            }
            ]]></code>
            </example>
            <seealso href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnJointBreak.html">
            Unity 3D: OnJointBreak</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IJointEventsListener.OnJointBreak(System.Single)">
            <summary>Triggers when connection is broken due to too strong force applied.</summary>
            <param name="breakForce">Actual force that has been applied.</param>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IKSPActivateOnDecouple">
            <summary>Documented analogue of IActivateOnDecouple interface.</summary>
            <remarks>
            Inherit from <see cref="T:IActivateOnDecouple"/> to be able reacting on parts decoupling.
            <see cref="T:KSPDev.KSPInterfaces.IKSPDevModuleInfo"/> is a full equivalent except it's documented.
            Inheriting modules from both interfaces gives better code documentation.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IActivateOnDecouple, IKSPActivateOnDecouple {
              /// <inheritdoc/>
              public virtual void DecoupleAction(string nodeName, bool weDecouple) {
                Debug.LogInfo("DecoupleAction");
              }
            }
            ]]></code>
            </example>
            <seealso href="https://kerbalspaceprogram.com/api/interface_i_activate_on_decouple.html">
            KSP: IActivateOnDecouple</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IKSPActivateOnDecouple.DecoupleAction(System.String,System.Boolean)">
            <summary>Called when two parts decouple.</summary>
            <remarks>
            Callback is only called on the part if it has an attach node that connects it to the other
            part. Just removing from the vessel hierarchy won't trigger the event.
            </remarks>
            <param name="nodeName">Attach node name that has been detached.</param>
            <param name="weDecouple">
            If <c>true</c> then the part being notified was a child in the relation of the detached part.
            </param>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IKSPDevModuleInfo">
            <summary>Documented analogue of IModuleInfo interface.</summary>
            <remarks>
            Inherit from <see cref="T:IModuleInfo"/> to be able customizing module descriptions for the
            editor. <see cref="T:KSPDev.KSPInterfaces.IKSPDevModuleInfo"/> is a full equivalent except it's documented. Inheriting
            modules from both interfaces gives better code documentation.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IPartModule, IModuleInfo, IKSPDevModuleInfo {
              /// <inheritdoc/>
              public override string GetInfo() {
                return "<size=20><color=#ff0000ff><b>BLAH!</b></color></size>";
              }
            }
            ]]></code>
            </example>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IKSPDevModuleInfo.GetInfo">
            <summary>Returns description for the editor part's browser.</summary>
            <remarks>
            Declared as virtual in <see cref="T:PartModule"/> and, hence, almost always needs to be
            overridden. Though, it's also a part of <see cref="T:IModuleInfo"/>.
            </remarks>
            <returns>
            Rich text to show the in GUI. Regular Unity rich text styles are supported.
            <para>
            Be careful when using &lt;size&gt;. It specifies size of the font in pixels which is an
            absolute value. As of KSP v1.1.3 normal info font size is 11px but in the future versions it
            may change.
            </para>
            </returns>
            <seealso href="https://docs.unity3d.com/Manual/StyledText.html">Unity 3D: Rich text</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IKSPDevModuleInfo.GetModuleTitle">
            <summary>Returns module title to show in the editor part's details panel.</summary>
            <returns>Title of the module.</returns>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IKSPDevModuleInfo.GetDrawModulePanelCallback">
            <summary>Returns a method delegate to draw a custom panel.</summary>
            <returns>Delegate or <c>null</c> if not necessary.</returns>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IKSPDevModuleInfo.GetPrimaryField">
            <summary>Return a string to be displayed in the main information box on the tooltip.</summary>
            <returns>String or <c>null</c> if nothing is that important to be up there.</returns>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IPartModule">
             <summary>Interface for KSP part module.</summary>
             <remarks>
             Naturally, KSP doesn't declare any part module interface (unfortunately), and all modder's
             modules just inherit from <see cref="T:PartModule"/>. This interface is introduced for the better
             OOP approach. It reveals methods that a regular module can override, and provides documentation
             for each of them.
             <para>
             Some methods of the module interface look familiar to the ones from Unity but they are not
             behaving in the same way in every scene. Moreover, not all methods get called in every scene.
             </para>
            
             <para>In the <i>loading scene</i> the callbacks are executed in the following order:</para>
             <list type="table">
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnAwake"/></term>
             <description>
             Notifies about creating new module. If it's a clone operation then all <see cref="T:KSPField"/>
             annotated fields have values from the part's config. Otherwise, all the fields are in the
             initial states.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnLoad(ConfigNode)"/></term>
             <description>
             The provided config node is the original configuration from the part's definition. All the
             annotated fields are populated before this method gets control.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnStart(PartModule.StartState)"/></term>
             <description>
             Is <b>not called</b> since the parts being created are prefabs and icon models. They are not
             real parts that behave on a vessel.
             </description>
             </item>
             </list>
            
             <para>In the <i>editor</i> the callbacks are executed in the following order:</para>
             <list type="table">
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnAwake"/></term>
             <description>
             Notifies about creating new module. If it's a clone operation then all <see cref="T:KSPField"/>
             annotated fields have values from the part's config. Otherwise, all the fields are in the
             initial states.
             <para>
             New parts in the editor are created via the clone operation. I.e. each time a part is dragged
             from the toolbar it's get cloned from the prefab.
             </para>
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnLoad(ConfigNode)"/></term>
             <description>Is <b>not called</b> for the new parts since they are clonned. When a saved vessel
             is loaded in the editor every part on the vessel gets this method called with the values from
             the save file. The annotated fields are populated from the file <i>before</i> this method gets
             control, so it's safe to use them.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnInitialize"/></term>
             <description>Hard to say what it means for the edtior, but important difference from the flight
             scenes is that this method is called before <see cref="M:KSPDev.KSPInterfaces.IPartModule.OnStart(PartModule.StartState)"/>.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnStart(PartModule.StartState)"/></term>
             <description>The code must check if the current scene is editor, and do the behavior changes as
             needed. In the editor parts must not have active behavior.
             </description>
             </item>
             </list>
            
             <para>In the <i>fligth scenes</i> the callbacks are executed in the following order:</para>
             <list type="table">
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnAwake"/></term>
             <description>Notifies about creating new module. All <see cref="T:KSPField"/> annotated fields
             have initial values.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnLoad(ConfigNode)"/></term>
             <description>The provided config node is the config from the save file. The annotated fields are
             populated from the file <i>before</i> this method gets control, so it's safe to use them.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnStart(PartModule.StartState)"/></term>
             <description>This method is called when all parts in the vessel are created and loaded. The code
             must check if the current scene is flight, and do the behavior changes as needed.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnInitialize"/></term>
             <description>Indicates that part should start handling physics if any. It may be called multiple
             times during the part's life. First time it's called when vessel is completely loaded in the
             secene and all parts are started. Other calls may happen when game returns from a physics
             suspended state (e.g. from a warp mode back to x1 time speed).
             <para>
             Code must check if editor scene is loaded since this method is called differently in the editor.
             </para>
             </description>
             </item>
             </list>
            
             </remarks>
             <example>
             <code><![CDATA[
             public class MyModule : PartModule, IPartModule {
               /// <inheritdoc/>
               public override void OnAwake() {
               }
             }
             ]]></code>
             </example>
             <seealso href="https://kerbalspaceprogram.com/api/class_part_module.html">
             KSP: PartModule</seealso>
             <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_field.html">
             KSP: KSPField</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnAwake">
            <summary>Initializes a new instance of the module on the part.</summary>
            <remarks>
            Called on a newly created part. Note, that this method is a bad place to interact with the
            other modules on the part since module initialization order is not defined.
            <para>See more details on the calling sequence in <see cref="T:KSPDev.KSPInterfaces.IPartModule"/>.</para>
            </remarks>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnLoad(ConfigNode)">
            <summary>Notifies that the part's config is loaded.</summary>
            <remarks>
            All the fields annotated by <see cref="T:KSPField"/> are already loaded at this moment. Use the
            node from this method to handle special values that are not supported by KSP.
            <para>See more details on the calling sequence in <see cref="T:KSPDev.KSPInterfaces.IPartModule"/>.</para>
            </remarks>
            <param name="node">Either the part's config node or a configuration from a save file.</param>
            <seealso href="https://kerbalspaceprogram.com/api/class_config_node.html">
            KSP: ConfigNode</seealso>
            <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_field.html">
            KSP: KSPField</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnStart(PartModule.StartState)">
            <summary>Initializes module's state after all other modules have been created.</summary>
            <remarks>
            Note, that this is not the right place to start physics on the part. This callback is good to
            establish connections between the other modules on the part.
            </remarks>
            <para>See more details on the calling sequence in <see cref="T:KSPDev.KSPInterfaces.IPartModule"/>.</para>
            <param name="state">State that specifies the situation of the vessel.</param>
            <seealso href="https://kerbalspaceprogram.com/api/class_part_module.html#ac6597127392e002b92f7427cf50244d3">
            KSP: PartModule.StartState</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnInitialize">
            <summary>
            Called on vessel go off rails. Basically, every time the vessel becomes physics.
            </summary>
            <remarks>Can be called multiple times during the part's life.</remarks>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnUpdate">
            <summary>Notifies about a frame update.</summary>
            <remarks>
            Be very careful about placing functionality into this callback even if it's bare "if/else"
            statement. This callback is called on <b>every</b> frame update. It means that even a simple
            piece of code will be called for every part that implements the module. Too many parts with
            such modules may significantly drop FPS.
            </remarks>
            <seealso href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html">
            Unity 3D: Update</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnFixedUpdate">
            <summary>Notifies about a physics frame update.</summary>
            <remarks>
            Physics in Unity is updated every <c>20ms</c> which gives 50 calls per a second. Be
            <i>extremly</i> careful about placing functionality into this callback. All fixed updates are
            required to complete, so if 50 updates take longer than one second then the game's speed will
            degrade.
            <para>In general, don't even override this callback unless it's absolutely required.</para>
            </remarks>
            <seealso href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html">
            Unity 3D: FixedUpdate</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnSave(ConfigNode)">
            <summary>Notifies about saving module state.</summary>
            <remarks>
            This isn't required to be saving into a real file. This method is a generic way to save module
            state when it's needed. Note, that saving <c>null</c> is usually a problem for KSP, so always
            give default non-null values to every persisted field.
            <para>
            Persistent fields annotated woth <see cref="T:KSPField"/> are saved before this callback is
            called. Only save values that need special handling. 
            </para>
            </remarks>
            <param name="node">Config node to save data into.</param>
            <seealso href="https://kerbalspaceprogram.com/api/class_config_node.html">
            KSP: ConfigNode</seealso>
            <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_field.html">
            KSP: KSPField</seealso>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IsDestroyable">
            <summary>Interface for modules that need to know if script object is destroyed.</summary>
            <remarks>
            Events of this inteface are triggered by Unity engine via reflections. It's not required for the
            module to implement the interface to be notified but by implementing it the code becomes more
            consistent and less error prone.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IsDestroyable {
              /// <inheritdoc/>
              public void OnDestory() {
                Debug.LogInfo("OnDestory");
              }
            }
            ]]></code>
            </example>
            <seealso href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDestroy.html">
            Unity 3D: OnDestroy</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IsDestroyable.OnDestroy">
            <summary>Triggers when Unity object is about to destroy.</summary>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IsPackable">
            <summary>Interface to track physics state changes in the part's module.</summary>
            <remarks>
            Events of this inteface are triggered by KSP engine via Unity messaging mechanism. It's not
            required for the module to implement the interface to be notified but by implementing it the
            code becomes more consistent and less error prone.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IsPackable {
              /// <inheritdoc/>
              public void OnPartPack() {
                Debug.LogInfo("OnPartPack");
              }
              /// <inheritdoc/>
              public void OnPartUnpack() {
                Debug.LogInfo("OnPartUnpack);
              }
            }
            ]]></code>
            </example>
            <seealso href="https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html">
            Unity 3D: GameObject.SendMessage</seealso>
            <seealso href="https://kerbalspaceprogram.com/api/class_part.html">KSP: Part</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IsPackable.OnPartPack">
            <summary>Triggers when physics stops on the part.</summary>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IsPackable.OnPartUnpack">
            <summary>Triggers when physics starts on the part.</summary>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IsPhysicalObject">
            <summary>Interface for modules that need handling physics.</summary>
            <remarks>
            Events of this inteface are triggered by Unity engine via reflections. It's not required for the
            module to implement the interface to be notified but by implementing it the code becomes more
            consistent and less error prone.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IsPhysicalObject {
              /// <inheritdoc/>
              public void FixedUpdate() {
                // Do physics stuff.
              }
            }
            ]]></code>
            </example>
            <seealso href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html">
            Unity 3D: FixedUpdate</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IsPhysicalObject.FixedUpdate">
            <summary>Notifies that fixed framerate frame is being handled.</summary>
            <remarks>
            This method is called by Unity via reflections, so it's not required to implement the
            interface. Though, it's a good idea to implement this interface in objects/modules that need
            physics updates to make code more readable.
            </remarks>
        </member>
        <member name="T:KSPDev.LogUtils.DbgFormatter">
            <summary>A set of tools to format various game enities for debugging purposes.</summary>
        </member>
        <member name="M:KSPDev.LogUtils.DbgFormatter.PartId(Part)">
            <summary>Returns a user friendly unique description of the part.</summary>
            <param name="p">Part to get ID string for.</param>
            <returns>ID string.</returns>
        </member>
        <member name="M:KSPDev.LogUtils.DbgFormatter.C2S``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String})">
            <summary>Flatterns collection items into a comma separated string.</summary>
            <remarks>This method's name is a shorthand for "Collection-To-String". Given a collection
            (e.g. list, set, or anything else implementing <c>IEnumarable</c>) this method transforms it
            into a human readable string.</remarks>
            <param name="collection">A collection to represent as a string.</param>
            <param name="predicate">A predicate to use to extract string representation of an item. If
            <c>null</c> then standard <c>ToString()</c> is used.</param>
            <returns>Human readable form of the collection.</returns>
            <typeparam name="TSource">Collection's item type.</typeparam>
        </member>
        <member name="T:KSPDev.ModelUtils.Colliders">
            <summary>Various tools to deal with procedural colliders.</summary>
        </member>
        <member name="M:KSPDev.ModelUtils.Colliders.SetSimpleCollider(UnityEngine.GameObject,UnityEngine.PrimitiveType,System.Boolean)">
            <summary>Drops colliders in all children objects, and adds one big collider to the parent.
            </summary>
            <remarks>
            Intended to create one fast collider at the cost of precision. All the meshes in the parent
            childs (including the parent) are processed to produce a boundary box. Then, this box is
            applied to the requested primitive type that defines the shape of the collider.
            <para>
            Note, that rdaius if sphere and capsule is the same in both X and Y axis. If combined boundary
            box has any of the dimensions significantly different then it makes sense to choose a
            different collider type. Or break down the hirearchy into more colliders.
            </para>
            </remarks>
            <param name="parent">Parent object.</param>
            <param name="type">
            Type of the primitive mesh which is the best for wrapping all the meshes of the object. Only
            <see cref="F:UnityEngine.PrimitiveType.Cube"/>, <see cref="F:UnityEngine.PrimitiveType.Capsule"/>, and
            <see cref="F:UnityEngine.PrimitiveType.Sphere"/> are supported.
            </param>
            <param name="inscribeBoundaryIntoCollider">
            If <c>true</c> then collider will define the outer boundaries so what all the meshes are
            inside the volume. Otherwise, the combined meshes box will define the outer boundary of the
            collider. It only makes sense for the colliders other than <see cref="F:UnityEngine.PrimitiveType.Cube"/>.
            </param>
            <seealso href="https://docs.unity3d.com/ScriptReference/GameObject.html">
            Unity 3D: GameObject</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/PrimitiveType.html">
            Unity 3D: PrimitiveType</seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Colliders.UpdateColliders(UnityEngine.GameObject,System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>Sets the specified values to colliders of all the objects in the part's model.
            </summary>
            <param name="parent">Game object to start searching for renderers from.</param>
            <param name="isPhysical">
            If <c>true</c> then collider will trigger physical effects. If <c>false</c> then it will only
            trigger collision events. When it's <c>null</c> the collider setting won't be changed.
            </param>
            <param name="isEnabled">
            Defines if colliders should be enabled or disabled. When it's <c>null</c> the collider setting
            won't be changed.
            </param>
            <seealso href="https://docs.unity3d.com/ScriptReference/Collider.html">Unity3D: Collider
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Colliders.AdjustCollider(UnityEngine.GameObject,UnityEngine.Vector3,KSPDev.ModelUtils.Colliders.PrimitiveCollider,System.Nullable{UnityEngine.PrimitiveType})">
            <summary>Adds or adjusts a primitive collider on the mesh.</summary>
            <remarks>
            Type of the primitive collider is chosen basing on the primitive type.
            </remarks>
            <param name="primitive">Primitive game object to adjust.</param>
            <param name="meshSize">Size of the collider in local units.</param>
            <param name="colliderType">Determines how a collider type should be selected.</param>
            <param name="shapeType">
            Type of the primitive when <paramref name="colliderType"/> is
            <see cref="F:KSPDev.ModelUtils.Colliders.PrimitiveCollider.Shape"/>. It will determine the type of the collider. Only
            <see cref="F:UnityEngine.PrimitiveType.Cylinder"/>, <see cref="F:UnityEngine.PrimitiveType.Sphere"/>, and
            <see cref="F:UnityEngine.PrimitiveType.Cube"/> are supported.
            </param>
        </member>
        <member name="T:KSPDev.ModelUtils.Colliders.PrimitiveCollider">
            <summary>Defines how collisions should be checked on a primitive.</summary>
        </member>
        <member name="F:KSPDev.ModelUtils.Colliders.PrimitiveCollider.None">
            <summary>No collisions check.</summary>
        </member>
        <member name="F:KSPDev.ModelUtils.Colliders.PrimitiveCollider.Mesh">
            <summary>Check collisions basing on the mesh. It's performance expensive.</summary>
            <seealso href="https://docs.unity3d.com/ScriptReference/MeshCollider.html">
            Unity3D: MeshCollider</seealso>
        </member>
        <member name="F:KSPDev.ModelUtils.Colliders.PrimitiveCollider.Shape">
            <summary>Simple collider which fits the primitive type. It's performance optimized.</summary>
            <seealso href="https://docs.unity3d.com/ScriptReference/PrimitiveType.html">
            Unity3D: PrimitiveType</seealso>
        </member>
        <member name="F:KSPDev.ModelUtils.Colliders.PrimitiveCollider.Bounds">
            <summary>Simple collider which wraps all mesh vertexes. It's performance optimized.</summary>
        </member>
        <member name="T:KSPDev.ModelUtils.Hierarchy">
            <summary>Various tools to deal with game object hierarchy.</summary>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.MoveToParent(UnityEngine.Transform,UnityEngine.Transform,System.Nullable{UnityEngine.Vector3},System.Nullable{UnityEngine.Quaternion},System.Nullable{UnityEngine.Vector3})">
            <summary>Changes transform's parent keeping local postion, rotation and scale.</summary>
            <remarks>
            Normally, Unity preserves world position, rotation and scale when changing parent. It's
            convinient when managing objects in a prefab but is not desired when constructing a new model.
            </remarks>
            <param name="child">Transform to change parent for.</param>
            <param name="parent">Transform to change parent to.</param>
            <param name="newPosition">Local position to set instead of the original one.</param>
            <param name="newRotation">Local rotation to set instead of the original one.</param>
            <param name="newScale">Local scale to set instead of the original one.</param>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.FindTransformInChildren(UnityEngine.Transform,System.String)">
            <summary>Finds a transform by name down the hierarchy.</summary>
            <remarks>
            Implements breadth-first search approach to minimize depth of the found transform.
            </remarks>
            <param name="parent">Transfrom to start from.</param>
            <param name="name">Name of the transfrom.</param>
            <returns>Found transform or <c>null</c> if nothing is found.</returns>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.FindTransformByPath(UnityEngine.Transform,System.String)">
            <summary>Finds transform treating the name as a hierarchy path.</summary>
            <param name="parent">Transfrom to start looking from.</param>
            <param name="path">
            Path to the target. Path elements are separated by "/" symbol. Element can be name or a
            pattern.
            </param>
            <returns>Transform or <c>null</c> if nothing found.</returns>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.FindTransformByPath(UnityEngine.Transform,System.String[])">
            <summary>Finds transform treating the name as a hierarchy path.</summary>
            <remarks>
            Elements of the path may specify exact transform name or be one of the following patterns:
            <list type="bullet">
            <item>
            "*" - any child  will match. I.e. all children of the preceding parent will be checked for the
            branch that follows the pattern. First full match will be returned. E.g. if the are parts
            "a/b/c" and "a/aa/c" then pattern "a/*/c" will match "a/b/c" since child "b" is the first in
            the children list. This pattern can be nested to specify that barcnh is expected to be found
            at the exact depth: "a/*/*/c".
            </item>
            <item>
            "**" - any path will match. I.e. all the branches of the preceding parent will be checked
            until one of them is matched the sub-path that follows the pattern. The shortest path is used
            in case of multple hits. E.g. if there are paths "a/b/c" and "a/c" then pattern "a/**/c" will
            match path "a/c". This pattern cannot be followed by another pattern, but it can follow "*"
            pattern, e.g. "a/*/**/c" (get "c" from any branch of "a" given the depth level is greater than
            1).
            </item>
            </list>
            <para>
            Keep in mind that patterns require children scan, and in a worst case scenario all the
            hirerachy can be scanned multiple times.
            </para>
            </remarks>
            <param name="parent">Transfrom to start looking from.</param>
            <param name="names">Path elements.</param>
            <returns>Transform or <c>null</c> if nothing found.</returns>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.GetPartModelTransform(Part)">
            <summary>Returns part's model transform.</summary>
            <param name="part">Part to get model for.</param>
            <returns>PartModel's transform if it was found. Part's trasnfrom otherwise.</returns>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.ListHirerahcy(UnityEngine.Transform,System.String)">
            <summary>
            Returns paths to all transformations in the object. Each item is a full path to the
            transformation.
            </summary>
            <param name="parent">Object to start from.</param>
            <param name="parentPath">
            Path to <paramref name="parent"/>. Leave it <c>null</c> if paths should start from "/".
            </param>
            <returns>paths to all transformations separated by LF symbol.</returns>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.GetFullPath(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>Returns full path to the object starting from the specified parent.</summary>
            <param name="obj">Object to find path for.</param>
            <param name="parent">Optional parent to use a root.</param>
            <returns>Full path to the object.</returns>
            <seealso cref="M:KSPDev.ModelUtils.Hierarchy.FindTransformByPath(UnityEngine.Transform,System.String[])"/>
        </member>
        <member name="T:KSPDev.ModelUtils.KspLayerMask">
            <summary>Flags for the collision layers in KSP.</summary>
            <remarks>
            It's not a full set of the layers. More investigation is needed to reveal all of them.
            </remarks>
        </member>
        <member name="F:KSPDev.ModelUtils.KspLayerMask.NONE">
            <summary>Just a default value that doesn't match any layer.</summary>
        </member>
        <member name="F:KSPDev.ModelUtils.KspLayerMask.PARTS">
            <summary>Layer for a regular part.</summary>
        </member>
        <member name="F:KSPDev.ModelUtils.KspLayerMask.SERVICE_LAYER">
            <summary>Layer to set bounds of a celestial body.</summary>
            <remarks>
            A very rough boundary of a planet, moon or asteroid. Used for macro objects detection.
            </remarks>
        </member>
        <member name="F:KSPDev.ModelUtils.KspLayerMask.SURFACE">
            <summary>"Zero" level of a static structure on the surface.</summary>
            <remarks>E.g. a launchpad.</remarks>
        </member>
        <member name="F:KSPDev.ModelUtils.KspLayerMask.KERBALS">
            <summary>Layer of kerbonaut models.</summary>
        </member>
        <member name="F:KSPDev.ModelUtils.KspLayerMask.FX">
            <summary>A layer for FX.</summary>
            <remarks>E.g. <c>PadFXReceiver</c> on the Kerbins VAB launchpad.</remarks>
        </member>
        <member name="T:KSPDev.ModelUtils.Meshes">
            <summary>Various tools to deal with procedural meshes.</summary>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.RescaleTextureToLength(UnityEngine.GameObject,System.Single,UnityEngine.Renderer)">
            <summary>
            Rescales texture so what one sample covers exactly one unit of the primitive length.
            </summary>
            <remarks>
            Normally one texture sample covers the whole primitive regardless to its length. By calling
            this method you ensure that one sample keeps its ratio comparing to a linear unit. If
            primitive is too short to fit the texture then the texture is truncated. If primitive is too
            long to be covered by one sample then the texture will be tiled to fill the space.
            <para>
            This methods assumes UV data on the primitive was created for a length of 1m. With this
            assumption in mind the Z axis of the local scale is cosidered "the length".
            <see cref="M:KSPDev.ModelUtils.Meshes.CreatePrimitive(UnityEngine.PrimitiveType,UnityEngine.Vector3,UnityEngine.Material,UnityEngine.Transform)"/> method guarantees that newly created primitive always has length
            of one meter but if primitive was created by other means its default length can be different.
            </para>
            </remarks>
            <param name="obj">Game object to adjust material on. Z axis scale gives the length.</param>
            <param name="lengthUnit">Length to be completly covered by one sample of the texture.
            </param>
            <param name="renderer">Specific renderer to adjust texture in. If <c>null</c> then first
            renderer on the object will be updated. Note, that getting renderer from the object is an
            expensive operation. When performance is the key it makes sense caching the renderer, and
            passing it in every rescale call.</param>
            <seealso href="https://docs.unity3d.com/ScriptReference/Renderer.html">Unity3D: Renderer
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.UpdateMaterials(UnityEngine.GameObject,System.String,System.Nullable{UnityEngine.Color})">
            <summary>
            Sets the specified values to material of all the renderers in the part's model.
            </summary>
            <remarks>
            Shared material is affected, so if there are unrelated meshes that use the same material then
            they will be affected as well. In general, it's a bad idea to share material between several
            parts. And it's a good practice to share materials within the same part.
            </remarks>
            <param name="parent">Game object to start searching for renderers from.</param>
            <param name="newShaderName">
            New shader name. If <c>null</c> then it will not be changed.
            </param>
            <param name="newColor">Color to set. If <c>null</c> then it will not be changed.</param>
            <seealso href="https://docs.unity3d.com/ScriptReference/Shader.html">Unity3D: Shader</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Material.html">Unity3D: Material
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.CreateCylinder(System.Single,System.Single,UnityEngine.Material,UnityEngine.Transform,KSPDev.ModelUtils.Colliders.PrimitiveCollider)">
            <summary>Creates a cylinder.</summary>
            <param name="diameter">XY of the cylinder.</param>
            <param name="length">Z-axis of the cylinder.</param>
            <param name="material">Material for the primitive.</param>
            <param name="parent">Parent transfrom to atatch primitive to.</param>
            <param name="colliderType">Type of the collider to create on the primitive.</param>
            <returns>Sphere game object.</returns>
            <seealso href="https://docs.unity3d.com/ScriptReference/Material.html">Unity3D: Material
            </seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Transform.html">Unity3D: Transform
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.CreateBox(System.Single,System.Single,System.Single,UnityEngine.Material,UnityEngine.Transform,KSPDev.ModelUtils.Colliders.PrimitiveCollider)">
            <summary>Creates a box.</summary>
            <param name="width">X-axis of the box.</param>
            <param name="height">Y-axis of the box.</param>
            <param name="length">Z-axis of the box.</param>
            <param name="material">Material for the primitive.</param>
            <param name="parent">Parent transfrom to atatch primitive to.</param>
            <param name="colliderType">Type of the collider to create on the primitive.</param>
            <returns>Sphere game object.</returns>
            <seealso href="https://docs.unity3d.com/ScriptReference/Material.html">Unity3D: Material
            </seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Transform.html">Unity3D: Transform
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.CreateSphere(System.Single,UnityEngine.Material,UnityEngine.Transform,KSPDev.ModelUtils.Colliders.PrimitiveCollider)">
            <summary>Creates an ideal sphere.</summary>
            <param name="diameter">Diameter of the sphere.</param>
            <param name="material">Material for the primitive.</param>
            <param name="parent">Parent transfrom to atatch primitive to.</param>
            <param name="colliderType">Type of the collider to create on the primitive.</param>
            <returns>Sphere game object.</returns>
            <seealso href="https://docs.unity3d.com/ScriptReference/Material.html">Unity3D: Material
            </seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Transform.html">Unity3D: Transform
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.CreatePrimitive(UnityEngine.PrimitiveType,UnityEngine.Vector3,UnityEngine.Material,UnityEngine.Transform)">
            <summary>Creates a primitive mesh and attaches it to the model.</summary>
            <remarks>
            For <see cref="F:UnityEngine.PrimitiveType.Cylinder"/> Z and Y axis will be swapped to make Z "the length".
            <para>
            Collider on the primitive will be destroyed. Consider using
            <see cref="M:KSPDev.ModelUtils.Colliders.AdjustCollider(UnityEngine.GameObject,UnityEngine.Vector3,KSPDev.ModelUtils.Colliders.PrimitiveCollider,System.Nullable{UnityEngine.PrimitiveType})"/> to setup the right collider when needed.
            </para>
            </remarks>
            <param name="type">Type of the primitive.</param>
            <param name="meshScale">
            Scale to bring all mesh vertices to. New primitive have base size of 1m but some shapes may
            have exceptions (e.g. height of a cylinder is 2m). The scale is applied on the mesh, i.e. it's
            applied on the vertices, not the transform.</param>
            <param name="material">Material to use for the primitive.</param>
            <param name="parent">Parent transform to attach primitive to.</param>
            <returns>Game object of the new primitive.</returns>
            <seealso href="https://docs.unity3d.com/ScriptReference/GameObject.CreatePrimitive.html">
            Unity3D: GameObject.CreatePrimitive</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Material.html">Unity3D: Material
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.TranslateMesh(UnityEngine.GameObject,System.Nullable{UnityEngine.Vector3},System.Nullable{UnityEngine.Quaternion},System.Nullable{UnityEngine.Vector3})">
            <summary>Translates meshes's verticies.</summary>
            <remarks>
            This is different from setting postion, rotation and scale to the transform. This method
            actually changes vetricies in the mesh. It's not performance effective, so avoid doing it
            frequiently.
            </remarks>
            <param name="model">Model object to change mesh in.</param>
            <param name="offset">
            Offset for the verticies. If not specified then offset is zero. Offset is added <i>after</i>
            scale and rotation have been applied.  
            </param>
            <param name="rotation">
            Rotation for the verticies. If not set then no rotation is added.
            </param>
            <param name="scale">
            Scale for the vertex positions. If not specified then scale is not affected.
            </param>
        </member>
        <member name="T:KSPDev.ProcessingUtils.AsyncCall">
            <summary>Set of tools to execute a delayed code.</summary>
            <remarks>
            Use these tools when code needs to be executed with some delay or at a specific moment of the
            game.
            <code><![CDATA[
            class MyComponent : MonoBehaviour {
              void MyAsyncMethod(string a, int b) {
                Debug.DebugLogInfo("MyAsyncMethod({0}, {1})", a, b);
              }
              void Update() {
                // Call method at the end of the current frame.
                AsyncCall.CallOnEndOfFrame(this, x => MyAsyncMethod("a", 1));
                // Call method after 5 seconds timeout.
                AsyncCall.CallOnTimeout(this, 5.0f, x => MyAsyncMethod("b", 2));
                // Call method on the next fixed update.
                AsyncCall.CallOnFixedUpdate(this, x => MyAsyncMethod("c", 3));
              }
            }
            ]]></code>
            </remarks>
        </member>
        <member name="M:KSPDev.ProcessingUtils.AsyncCall.CallOnEndOfFrame(UnityEngine.MonoBehaviour,KSPDev.ProcessingUtils.AsyncCall.Action0,System.Object[])">
            <summary>Delays execution of the delegate till the end of the current frame.</summary>
            <remarks>
            Caller can continue executing its logic. The delegate will be called at the end of
            the frame via Unity StartCoroutine mechanism. The delegate will be called only once.
            </remarks>
            <param name="mono">
            Unity object to run coroutine on. If this object dies then the async call will not be invoked.
            </param>
            <param name="action">Delegate to execute.</param>
            <param name="args">Arguments to pass to the delegate.</param>
            <returns>Coroutine instance.</returns>
            <seealso href="https://docs.unity3d.com/Manual/Coroutines.html">Unity 3D: Coroutines</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html">
            Unity 3D: WaitForEndOfFrame</seealso>
        </member>
        <member name="M:KSPDev.ProcessingUtils.AsyncCall.CallOnTimeout(UnityEngine.MonoBehaviour,System.Single,KSPDev.ProcessingUtils.AsyncCall.Action0,System.Object[])">
            <summary>Delays execution of the delegate for the specified amount of time.</summary>
            <remarks>
            Caller can continue executing its logic. The delegate will be called once the timeout is
            expired via Unity StartCoroutine mechanism. The delegate will be called only once.
            <para>Using returned instance caller may cancel the call before the timeout expired.</para>
            </remarks>
            <param name="mono">
            Unity object to run coroutine on. If this object dies then the async call will not be invoked.
            </param>
            <param name="seconds">Timeout in seconds.</param>
            <param name="action">Delegate to execute.</param>
            <param name="args">Arguments to pass to the delegate.</param>
            <returns>Coroutine instance.</returns>
            <seealso href="https://docs.unity3d.com/Manual/Coroutines.html">Unity 3D: Coroutines</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/WaitForSeconds.html">
            Unity 3D: WaitForSeconds</seealso>
        </member>
        <member name="M:KSPDev.ProcessingUtils.AsyncCall.CallOnFixedUpdate(UnityEngine.MonoBehaviour,KSPDev.ProcessingUtils.AsyncCall.Action0,System.Object[])">
            <summary>Delays execution of the delegate till the next fixed update.</summary>
            <remarks>
            Caller can continue executing its logic. The delegate will be called at the beginning of the
            next fixed (physics) update via Unity StartCoroutine mechanism. The delegate will be called
            only once.
            </remarks>
            <param name="mono">
            Unity object to run coroutine on. If this object dies then the async call will not be invoked.
            </param>
            <param name="action">Delegate to execute.</param>
            <param name="args">Arguments to pass to the delegate.</param>
            <returns>Coroutine instance.</returns>
            <seealso href="https://docs.unity3d.com/Manual/Coroutines.html">Unity 3D: Coroutines</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/WaitForFixedUpdate.html">
            Unity 3D: WaitForFixedUpdate</seealso>
        </member>
        <member name="T:KSPDev.ProcessingUtils.AsyncCall.Action0">
            <summary>Delayed execution delegate.</summary>
            <param name="list">Optional list of parameters.</param>
        </member>
        <member name="T:KSPDev.ProcessingUtils.SimpleStateMachine`1">
             <summary>
             Simple state machine that allows tracking states and checking basic conditions.
             </summary>
             <remarks>
             If module has more that two modes (which can be controlled by a simple boolean) in makes sense
             to define each mode as a state, and intorduce a definite state transition diagram. Once it's
             done most of the mode changes logic can be mvoed in state transition callbacks. Such approach
             significantly simplifies the code and makes it less error prone.
             </remarks>
             <typeparam name="T">
             Enum to use as state constants. Note, that state machine won't consider any value of the enum as
             a valid state. Valid states must be defined via <see cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.SetTransitionConstraint(`0,`0[])"/>.
             </typeparam>
             <example>
             Here is an example of a module with three states with the following logic:
             <list type="bullet">
             <item>State <c>One</c> can be transitioned into both <c>Two</c> and <c>Three</c>.</item>
             <item>States <c>Two</c> and <c>Three</c> can only return back to <c>One</c>.</item>
             <item>In states <c>Two</c> and <c>Three</c> different menu options are available.</item>
             <item>In state <c>One</c> no menu options are available.</item>
             </list>
             <code><![CDATA[
             class MyModule : PartModule {
               enum MyState {
                 One, Two, Three
               }
            
               [KSPField(isPersistant = true)]
               public MyState persistedState = MyState.One;  // ALWAYS provide a default value!
            
               SimpleStateMachine<MyState> linkStateMachine;
            
               [KSPEvent(guiName = "State: TWO")]
               public void StateTwoMenuAction() {
                 Debug.LogInfo("StateTwoMenuAction()");
               }
            
               [KSPEvent(guiName = "State: THREE")]
               public void StateThreeMenuAction() {
                 Debug.LogInfo("StateThreeMenuAction()");
               }
            
               public override OnAwake() {
                 linkStateMachine = new SimpleStateMachine<MyState>(true /* strict */);
                 linkStateMachine.SetTransitionConstraint(
                     MyState.One,
                     new[] {MyState.Two, MyState.Three});
                 linkStateMachine.SetTransitionConstraint(
                     MyState.Two,
                     new[] {MyState.One});
                 linkStateMachine.SetTransitionConstraint(
                     MyState.Three,
                     new[] {MyState.One});
                 linkStateMachine.AddStateHandlers(
                     MyState.One,
                     enterHandler: x => {
                       Events["StateTwoMenuAction"].active = false;
                       Events["StateThreeMenuAction"].active = false;
                     });
                 linkStateMachine.AddStateHandlers(
                     MyState.Two,
                     enterHandler: x => {
                       Events["StateTwoMenuAction"].active = true;
                       Events["StateThreeMenuAction"].active = false;
                     });
                 linkStateMachine.AddStateHandlers(
                     MyState.Three,
                     enterHandler: x => {
                       Events["StateTwoMenuAction"].active = false;
                       Events["StateThreeMenuAction"].active = true;
                     });
               }
            
               public override void OnStart(PartModule.StartState state) {
                 linkStateMachine.Start(persistedState);  // Restore state from the save file.
               }
            
               void OnDestory() {
                 // Usually, this isn't needed. But if code needs to do a cleanup job it makes sense to wrap
                 // it into a handler, and stop the machine in Unity destructor.
                 linkStateMachine.Stop();
               }
            
               public override OnUpdate() {
                 if (Input.GetKeyDown("1")) {
                   // This transition will always succceed. 
                   stateMachine.currentState = MyState.One;
                 }
                 if (Input.GetKeyDown("2")) {
                   // This transition will only succceed if current state is MyState.One. 
                   stateMachine.currentState = MyState.Two;
                 }
                 if (Input.GetKeyDown("3")) {
                   // This transition will only succceed if current state is MyState.One. 
                   stateMachine.currentState = MyState.Three;
                 }
               }
             }
             ]]></code>
             <para>
             The same logic could be achivied in a different way. Instead of enabling/disabling all the menu
             items in every "enter" handler the code could define "leave" handlers that would disable the
             related menu item. This way every state handler would control own menu item without interacting
             with any existing or future items.
             </para>
             </example>
             <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_field.html">
             KSP: KSPField</seealso>
             <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_event.html">
             KSP: KSPEvent</seealso>
        </member>
        <member name="F:KSPDev.ProcessingUtils.SimpleStateMachine`1.OnDebugStateChange">
            <summary>
            Debug handler for tracking state changes. Avoid using it in normal code logic.
            </summary>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.#ctor(System.Boolean)">
            <summary>Constructs new unstarted state machine.</summary>
            <param name="strict">
            If <c>true</c> then only transitions defined via <see cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.SetTransitionConstraint(`0,`0[])"/> will be
            allowed.
            </param>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.Start(`0)">
            <summary>Starts state machine and makes it available for state transitions.</summary>
            <remarks>
            Until machine is started state transitions are not possible. Attempt to change to any state
            will result in <see cref="T:System.InvalidOperationException"/>.
            <para>Starting of the machine will trigger enter state event.</para>
            </remarks>
            <param name="startState">Initial state of the machine.</param>
            <seealso cref="P:KSPDev.ProcessingUtils.SimpleStateMachine`1.isStarted"/>
            <seealso cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.AddStateHandlers(`0,KSPDev.ProcessingUtils.SimpleStateMachine{`0}.OnChange,KSPDev.ProcessingUtils.SimpleStateMachine{`0}.OnChange)"/>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.Stop">
            <summary>Stops stat machine making it unavailable for any state transitions.</summary>
            <remarks>
            If machine is not started yet then this call is NO-OP.
            <para>Stoping of the machine will trigger leave state event.</para>
            </remarks>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.SetTransitionConstraint(`0,`0[])">
            <summary>Defines source state and, optionally, allowed trasitions.</summary>
            <remarks>
            State machine figures out full set the allowed states from the transitions. Even if transition
            mode is not strict all the states must be defined via tarnsitions (eitehr as a source or a
            target).
            <para>In strict mode it's required that every transition is declared excplicitly.</para>
            <para>If called multiple times then only last call's setup will be stored.</para>
            <para>State machine must be in stopped state. Otherwise, an exception will thrown.</para>
            </remarks>
            <param name="fromState">Source state.</param>
            <param name="toStates">
            List of states that are allowed as targets for <paramref name="fromState"/>.
            </param>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.ResetTransitionConstraint(`0)">
            <summary>Clears transitions for the soucre state if any.</summary>
            <remarks>
            Note, that source state is cleared as well. If it's not mentioned in other transitions then
            state machine will completely forget the state.
            </remarks>
            <param name="fromState">Source state to clear tarnsitions for.</param>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.ForceSetState(`0)">
            <summary>Changes current state bypassing any transition or state changes.</summary>
            <remarks>
            It's discouraged to use this method in normal flow. Though, you it may be handy when
            recovering module from an unknown state (e.g. an unexpected exception in the middle of the
            process).
            </remarks>
            <param name="newState">
            New current state. It can be a state that is not mentioned in any state transition.
            </param>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.AddStateHandlers(`0,KSPDev.ProcessingUtils.SimpleStateMachine{`0}.OnChange,KSPDev.ProcessingUtils.SimpleStateMachine{`0}.OnChange)">
            <summary>Adds listeners for state enter/leave events.</summary>
            <remarks>
            Note, that code must not expect that handlers will be called in the same order as they were
            added. Each handler must be independent from the others.
            <para>Multiple calls for the same handler and state won't create multiple entries.</para>
            </remarks>
            <param name="state">State to call callbacke on.</param>
            <param name="enterHandler">
            Callback to call when state machine has switched to a new state. Callback is triggered
            <i>after</i> the state has actually changed.
            </param>
            <param name="leaveHandler">
            Callback to call when state machine is going to leave the current state. Callback is triggered
            <i>before</i> the state has actually changed. 
            </param>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.RemoveHandlers(`0,KSPDev.ProcessingUtils.SimpleStateMachine{`0}.OnChange,KSPDev.ProcessingUtils.SimpleStateMachine{`0}.OnChange)">
            <summary>Removes enter state change event handler.</summary>
            <remarks>It's safe to call it for non-existing handler.</remarks>
            <param name="state">State to delete handler for.</param>
            <param name="enterHandler">Enter state handler to delete.</param>
            <param name="leaveHandler">Leave state handler to delete.</param>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.CheckCanSwitchTo(`0)">
            <summary>Verifies if transition is allowed.</summary>
            <param name="newState">State to check transition into.</param>
            <returns><c>true</c> if transition is allowed.</returns>
            <seealso cref="P:KSPDev.ProcessingUtils.SimpleStateMachine`1.isStrict"/>
            <seealso cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.SetTransitionConstraint(`0,`0[])"/>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.CheckIsStarted">
            <summary>Verifies that state machine is started.</summary>
            <exception cref="T:System.InvalidOperationException">If state machine is not yet started.</exception>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.CheckIsNotStarted">
            <summary>Verifies that state machine is <i>not</i> started.</summary>
            <exception cref="T:System.InvalidOperationException">If state machine is already started.</exception>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.SetState(`0)">
            <summary>
            Changes machine's state if current and new states are different. Checks if transition is
            allowed before actually changing state.
            </summary>
            <param name="newState">State to change to.</param>
            <seealso cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.CheckCanSwitchTo(`0)"/>
            <exception cref="T:System.InvalidOperationException">If transition is not allowed.</exception>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.FireLeaveState">
            <summary>Notifies all the leave handlers about leaving the current state.</summary>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.FireEnterState">
            <summary>Notifies all the enter handlers about entering the current state.</summary>
        </member>
        <member name="P:KSPDev.ProcessingUtils.SimpleStateMachine`1.currentState">
            <summary>Current state of the machine.</summary>
            <remarks>
            Setting same state as the current one is NO-OP. Setting of a new state may be blocked in
            strict mode.
            </remarks>
            <seealso cref="P:KSPDev.ProcessingUtils.SimpleStateMachine`1.isStrict"/>
            <seealso cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.ForceSetState(`0)"/>
        </member>
        <member name="P:KSPDev.ProcessingUtils.SimpleStateMachine`1.isStarted">
            <summary>Tells if state machine is started.</summary>
            <seealso cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.Start(`0)"/>
        </member>
        <member name="P:KSPDev.ProcessingUtils.SimpleStateMachine`1.isStrict">
            <summary>
            Tells if invalid state transitions will be blocked.  
            </summary>
            <seealso cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.SetTransitionConstraint(`0,`0[])"/>
        </member>
        <member name="T:KSPDev.ProcessingUtils.SimpleStateMachine`1.OnChange">
            <summary>Delegate for callback which notifies about state change.</summary>
            <param name="state">Current state of the machine.</param>
        </member>
        <member name="T:KSPDev.ProcessingUtils.SimpleStateMachine`1.OnDebugChange">
            <summary>Special debug delegate to track state changes.</summary>
            <remarks>This callback is called before actual state change.</remarks>
            <param name="fromState">State before change.</param>
            <param name="toState">State after change.</param>
        </member>
    </members>
</doc>
